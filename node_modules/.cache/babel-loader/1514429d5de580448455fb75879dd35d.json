{"ast":null,"code":"const Utils = require('./utils');\n\nconst ECLevel = require('./error-correction-level');\n\nconst BitBuffer = require('./bit-buffer');\n\nconst BitMatrix = require('./bit-matrix');\n\nconst AlignmentPattern = require('./alignment-pattern');\n\nconst FinderPattern = require('./finder-pattern');\n\nconst MaskPattern = require('./mask-pattern');\n\nconst ECCode = require('./error-correction-code');\n\nconst ReedSolomonEncoder = require('./reed-solomon-encoder');\n\nconst Version = require('./version');\n\nconst FormatInfo = require('./format-info');\n\nconst Mode = require('./mode');\n\nconst Segments = require('./segments');\n/**\n * QRCode for JavaScript\n *\n * modified by Ryan Day for nodejs support\n * Copyright (c) 2011 Ryan Day\n *\n * Licensed under the MIT license:\n *   http://www.opensource.org/licenses/mit-license.php\n *\n//---------------------------------------------------------------------\n// QRCode for JavaScript\n//\n// Copyright (c) 2009 Kazuhiko Arase\n//\n// URL: http://www.d-project.com/\n//\n// Licensed under the MIT license:\n//   http://www.opensource.org/licenses/mit-license.php\n//\n// The word \"QR Code\" is registered trademark of\n// DENSO WAVE INCORPORATED\n//   http://www.denso-wave.com/qrcode/faqpatent-e.html\n//\n//---------------------------------------------------------------------\n*/\n\n/**\n * Add finder patterns bits to matrix\n *\n * @param  {BitMatrix} matrix  Modules matrix\n * @param  {Number}    version QR Code version\n */\n\n\nfunction setupFinderPattern(matrix, version) {\n  const size = matrix.size;\n  const pos = FinderPattern.getPositions(version);\n\n  for (let i = 0; i < pos.length; i++) {\n    const row = pos[i][0];\n    const col = pos[i][1];\n\n    for (let r = -1; r <= 7; r++) {\n      if (row + r <= -1 || size <= row + r) continue;\n\n      for (let c = -1; c <= 7; c++) {\n        if (col + c <= -1 || size <= col + c) continue;\n\n        if (r >= 0 && r <= 6 && (c === 0 || c === 6) || c >= 0 && c <= 6 && (r === 0 || r === 6) || r >= 2 && r <= 4 && c >= 2 && c <= 4) {\n          matrix.set(row + r, col + c, true, true);\n        } else {\n          matrix.set(row + r, col + c, false, true);\n        }\n      }\n    }\n  }\n}\n/**\n * Add timing pattern bits to matrix\n *\n * Note: this function must be called before {@link setupAlignmentPattern}\n *\n * @param  {BitMatrix} matrix Modules matrix\n */\n\n\nfunction setupTimingPattern(matrix) {\n  const size = matrix.size;\n\n  for (let r = 8; r < size - 8; r++) {\n    const value = r % 2 === 0;\n    matrix.set(r, 6, value, true);\n    matrix.set(6, r, value, true);\n  }\n}\n/**\n * Add alignment patterns bits to matrix\n *\n * Note: this function must be called after {@link setupTimingPattern}\n *\n * @param  {BitMatrix} matrix  Modules matrix\n * @param  {Number}    version QR Code version\n */\n\n\nfunction setupAlignmentPattern(matrix, version) {\n  const pos = AlignmentPattern.getPositions(version);\n\n  for (let i = 0; i < pos.length; i++) {\n    const row = pos[i][0];\n    const col = pos[i][1];\n\n    for (let r = -2; r <= 2; r++) {\n      for (let c = -2; c <= 2; c++) {\n        if (r === -2 || r === 2 || c === -2 || c === 2 || r === 0 && c === 0) {\n          matrix.set(row + r, col + c, true, true);\n        } else {\n          matrix.set(row + r, col + c, false, true);\n        }\n      }\n    }\n  }\n}\n/**\n * Add version info bits to matrix\n *\n * @param  {BitMatrix} matrix  Modules matrix\n * @param  {Number}    version QR Code version\n */\n\n\nfunction setupVersionInfo(matrix, version) {\n  const size = matrix.size;\n  const bits = Version.getEncodedBits(version);\n  let row, col, mod;\n\n  for (let i = 0; i < 18; i++) {\n    row = Math.floor(i / 3);\n    col = i % 3 + size - 8 - 3;\n    mod = (bits >> i & 1) === 1;\n    matrix.set(row, col, mod, true);\n    matrix.set(col, row, mod, true);\n  }\n}\n/**\n * Add format info bits to matrix\n *\n * @param  {BitMatrix} matrix               Modules matrix\n * @param  {ErrorCorrectionLevel}    errorCorrectionLevel Error correction level\n * @param  {Number}    maskPattern          Mask pattern reference value\n */\n\n\nfunction setupFormatInfo(matrix, errorCorrectionLevel, maskPattern) {\n  const size = matrix.size;\n  const bits = FormatInfo.getEncodedBits(errorCorrectionLevel, maskPattern);\n  let i, mod;\n\n  for (i = 0; i < 15; i++) {\n    mod = (bits >> i & 1) === 1; // vertical\n\n    if (i < 6) {\n      matrix.set(i, 8, mod, true);\n    } else if (i < 8) {\n      matrix.set(i + 1, 8, mod, true);\n    } else {\n      matrix.set(size - 15 + i, 8, mod, true);\n    } // horizontal\n\n\n    if (i < 8) {\n      matrix.set(8, size - i - 1, mod, true);\n    } else if (i < 9) {\n      matrix.set(8, 15 - i - 1 + 1, mod, true);\n    } else {\n      matrix.set(8, 15 - i - 1, mod, true);\n    }\n  } // fixed module\n\n\n  matrix.set(size - 8, 8, 1, true);\n}\n/**\n * Add encoded data bits to matrix\n *\n * @param  {BitMatrix}  matrix Modules matrix\n * @param  {Uint8Array} data   Data codewords\n */\n\n\nfunction setupData(matrix, data) {\n  const size = matrix.size;\n  let inc = -1;\n  let row = size - 1;\n  let bitIndex = 7;\n  let byteIndex = 0;\n\n  for (let col = size - 1; col > 0; col -= 2) {\n    if (col === 6) col--;\n\n    while (true) {\n      for (let c = 0; c < 2; c++) {\n        if (!matrix.isReserved(row, col - c)) {\n          let dark = false;\n\n          if (byteIndex < data.length) {\n            dark = (data[byteIndex] >>> bitIndex & 1) === 1;\n          }\n\n          matrix.set(row, col - c, dark);\n          bitIndex--;\n\n          if (bitIndex === -1) {\n            byteIndex++;\n            bitIndex = 7;\n          }\n        }\n      }\n\n      row += inc;\n\n      if (row < 0 || size <= row) {\n        row -= inc;\n        inc = -inc;\n        break;\n      }\n    }\n  }\n}\n/**\n * Create encoded codewords from data input\n *\n * @param  {Number}   version              QR Code version\n * @param  {ErrorCorrectionLevel}   errorCorrectionLevel Error correction level\n * @param  {ByteData} data                 Data input\n * @return {Uint8Array}                    Buffer containing encoded codewords\n */\n\n\nfunction createData(version, errorCorrectionLevel, segments) {\n  // Prepare data buffer\n  const buffer = new BitBuffer();\n  segments.forEach(function (data) {\n    // prefix data with mode indicator (4 bits)\n    buffer.put(data.mode.bit, 4); // Prefix data with character count indicator.\n    // The character count indicator is a string of bits that represents the\n    // number of characters that are being encoded.\n    // The character count indicator must be placed after the mode indicator\n    // and must be a certain number of bits long, depending on the QR version\n    // and data mode\n    // @see {@link Mode.getCharCountIndicator}.\n\n    buffer.put(data.getLength(), Mode.getCharCountIndicator(data.mode, version)); // add binary data sequence to buffer\n\n    data.write(buffer);\n  }); // Calculate required number of bits\n\n  const totalCodewords = Utils.getSymbolTotalCodewords(version);\n  const ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel);\n  const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8; // Add a terminator.\n  // If the bit string is shorter than the total number of required bits,\n  // a terminator of up to four 0s must be added to the right side of the string.\n  // If the bit string is more than four bits shorter than the required number of bits,\n  // add four 0s to the end.\n\n  if (buffer.getLengthInBits() + 4 <= dataTotalCodewordsBits) {\n    buffer.put(0, 4);\n  } // If the bit string is fewer than four bits shorter, add only the number of 0s that\n  // are needed to reach the required number of bits.\n  // After adding the terminator, if the number of bits in the string is not a multiple of 8,\n  // pad the string on the right with 0s to make the string's length a multiple of 8.\n\n\n  while (buffer.getLengthInBits() % 8 !== 0) {\n    buffer.putBit(0);\n  } // Add pad bytes if the string is still shorter than the total number of required bits.\n  // Extend the buffer to fill the data capacity of the symbol corresponding to\n  // the Version and Error Correction Level by adding the Pad Codewords 11101100 (0xEC)\n  // and 00010001 (0x11) alternately.\n\n\n  const remainingByte = (dataTotalCodewordsBits - buffer.getLengthInBits()) / 8;\n\n  for (let i = 0; i < remainingByte; i++) {\n    buffer.put(i % 2 ? 0x11 : 0xEC, 8);\n  }\n\n  return createCodewords(buffer, version, errorCorrectionLevel);\n}\n/**\n * Encode input data with Reed-Solomon and return codewords with\n * relative error correction bits\n *\n * @param  {BitBuffer} bitBuffer            Data to encode\n * @param  {Number}    version              QR Code version\n * @param  {ErrorCorrectionLevel} errorCorrectionLevel Error correction level\n * @return {Uint8Array}                     Buffer containing encoded codewords\n */\n\n\nfunction createCodewords(bitBuffer, version, errorCorrectionLevel) {\n  // Total codewords for this QR code version (Data + Error correction)\n  const totalCodewords = Utils.getSymbolTotalCodewords(version); // Total number of error correction codewords\n\n  const ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel); // Total number of data codewords\n\n  const dataTotalCodewords = totalCodewords - ecTotalCodewords; // Total number of blocks\n\n  const ecTotalBlocks = ECCode.getBlocksCount(version, errorCorrectionLevel); // Calculate how many blocks each group should contain\n\n  const blocksInGroup2 = totalCodewords % ecTotalBlocks;\n  const blocksInGroup1 = ecTotalBlocks - blocksInGroup2;\n  const totalCodewordsInGroup1 = Math.floor(totalCodewords / ecTotalBlocks);\n  const dataCodewordsInGroup1 = Math.floor(dataTotalCodewords / ecTotalBlocks);\n  const dataCodewordsInGroup2 = dataCodewordsInGroup1 + 1; // Number of EC codewords is the same for both groups\n\n  const ecCount = totalCodewordsInGroup1 - dataCodewordsInGroup1; // Initialize a Reed-Solomon encoder with a generator polynomial of degree ecCount\n\n  const rs = new ReedSolomonEncoder(ecCount);\n  let offset = 0;\n  const dcData = new Array(ecTotalBlocks);\n  const ecData = new Array(ecTotalBlocks);\n  let maxDataSize = 0;\n  const buffer = new Uint8Array(bitBuffer.buffer); // Divide the buffer into the required number of blocks\n\n  for (let b = 0; b < ecTotalBlocks; b++) {\n    const dataSize = b < blocksInGroup1 ? dataCodewordsInGroup1 : dataCodewordsInGroup2; // extract a block of data from buffer\n\n    dcData[b] = buffer.slice(offset, offset + dataSize); // Calculate EC codewords for this data block\n\n    ecData[b] = rs.encode(dcData[b]);\n    offset += dataSize;\n    maxDataSize = Math.max(maxDataSize, dataSize);\n  } // Create final data\n  // Interleave the data and error correction codewords from each block\n\n\n  const data = new Uint8Array(totalCodewords);\n  let index = 0;\n  let i, r; // Add data codewords\n\n  for (i = 0; i < maxDataSize; i++) {\n    for (r = 0; r < ecTotalBlocks; r++) {\n      if (i < dcData[r].length) {\n        data[index++] = dcData[r][i];\n      }\n    }\n  } // Apped EC codewords\n\n\n  for (i = 0; i < ecCount; i++) {\n    for (r = 0; r < ecTotalBlocks; r++) {\n      data[index++] = ecData[r][i];\n    }\n  }\n\n  return data;\n}\n/**\n * Build QR Code symbol\n *\n * @param  {String} data                 Input string\n * @param  {Number} version              QR Code version\n * @param  {ErrorCorretionLevel} errorCorrectionLevel Error level\n * @param  {MaskPattern} maskPattern     Mask pattern\n * @return {Object}                      Object containing symbol data\n */\n\n\nfunction createSymbol(data, version, errorCorrectionLevel, maskPattern) {\n  let segments;\n\n  if (Array.isArray(data)) {\n    segments = Segments.fromArray(data);\n  } else if (typeof data === 'string') {\n    let estimatedVersion = version;\n\n    if (!estimatedVersion) {\n      const rawSegments = Segments.rawSplit(data); // Estimate best version that can contain raw splitted segments\n\n      estimatedVersion = Version.getBestVersionForData(rawSegments, errorCorrectionLevel);\n    } // Build optimized segments\n    // If estimated version is undefined, try with the highest version\n\n\n    segments = Segments.fromString(data, estimatedVersion || 40);\n  } else {\n    throw new Error('Invalid data');\n  } // Get the min version that can contain data\n\n\n  const bestVersion = Version.getBestVersionForData(segments, errorCorrectionLevel); // If no version is found, data cannot be stored\n\n  if (!bestVersion) {\n    throw new Error('The amount of data is too big to be stored in a QR Code');\n  } // If not specified, use min version as default\n\n\n  if (!version) {\n    version = bestVersion; // Check if the specified version can contain the data\n  } else if (version < bestVersion) {\n    throw new Error('\\n' + 'The chosen QR Code version cannot contain this amount of data.\\n' + 'Minimum version required to store current data is: ' + bestVersion + '.\\n');\n  }\n\n  const dataBits = createData(version, errorCorrectionLevel, segments); // Allocate matrix buffer\n\n  const moduleCount = Utils.getSymbolSize(version);\n  const modules = new BitMatrix(moduleCount); // Add function modules\n\n  setupFinderPattern(modules, version);\n  setupTimingPattern(modules);\n  setupAlignmentPattern(modules, version); // Add temporary dummy bits for format info just to set them as reserved.\n  // This is needed to prevent these bits from being masked by {@link MaskPattern.applyMask}\n  // since the masking operation must be performed only on the encoding region.\n  // These blocks will be replaced with correct values later in code.\n\n  setupFormatInfo(modules, errorCorrectionLevel, 0);\n\n  if (version >= 7) {\n    setupVersionInfo(modules, version);\n  } // Add data codewords\n\n\n  setupData(modules, dataBits);\n\n  if (isNaN(maskPattern)) {\n    // Find best mask pattern\n    maskPattern = MaskPattern.getBestMask(modules, setupFormatInfo.bind(null, modules, errorCorrectionLevel));\n  } // Apply mask pattern\n\n\n  MaskPattern.applyMask(maskPattern, modules); // Replace format info bits with correct values\n\n  setupFormatInfo(modules, errorCorrectionLevel, maskPattern);\n  return {\n    modules: modules,\n    version: version,\n    errorCorrectionLevel: errorCorrectionLevel,\n    maskPattern: maskPattern,\n    segments: segments\n  };\n}\n/**\n * QR Code\n *\n * @param {String | Array} data                 Input data\n * @param {Object} options                      Optional configurations\n * @param {Number} options.version              QR Code version\n * @param {String} options.errorCorrectionLevel Error correction level\n * @param {Function} options.toSJISFunc         Helper func to convert utf8 to sjis\n */\n\n\nexports.create = function create(data, options) {\n  if (typeof data === 'undefined' || data === '') {\n    throw new Error('No input text');\n  }\n\n  let errorCorrectionLevel = ECLevel.M;\n  let version;\n  let mask;\n\n  if (typeof options !== 'undefined') {\n    // Use higher error correction level as default\n    errorCorrectionLevel = ECLevel.from(options.errorCorrectionLevel, ECLevel.M);\n    version = Version.from(options.version);\n    mask = MaskPattern.from(options.maskPattern);\n\n    if (options.toSJISFunc) {\n      Utils.setToSJISFunction(options.toSJISFunc);\n    }\n  }\n\n  return createSymbol(data, version, errorCorrectionLevel, mask);\n};","map":{"version":3,"sources":["/Users/sirin/go/src/github.com/sirinibin/reactjs-pos/node_modules/qrcode/lib/core/qrcode.js"],"names":["Utils","require","ECLevel","BitBuffer","BitMatrix","AlignmentPattern","FinderPattern","MaskPattern","ECCode","ReedSolomonEncoder","Version","FormatInfo","Mode","Segments","setupFinderPattern","matrix","version","size","pos","getPositions","i","length","row","col","r","c","set","setupTimingPattern","value","setupAlignmentPattern","setupVersionInfo","bits","getEncodedBits","mod","Math","floor","setupFormatInfo","errorCorrectionLevel","maskPattern","setupData","data","inc","bitIndex","byteIndex","isReserved","dark","createData","segments","buffer","forEach","put","mode","bit","getLength","getCharCountIndicator","write","totalCodewords","getSymbolTotalCodewords","ecTotalCodewords","getTotalCodewordsCount","dataTotalCodewordsBits","getLengthInBits","putBit","remainingByte","createCodewords","bitBuffer","dataTotalCodewords","ecTotalBlocks","getBlocksCount","blocksInGroup2","blocksInGroup1","totalCodewordsInGroup1","dataCodewordsInGroup1","dataCodewordsInGroup2","ecCount","rs","offset","dcData","Array","ecData","maxDataSize","Uint8Array","b","dataSize","slice","encode","max","index","createSymbol","isArray","fromArray","estimatedVersion","rawSegments","rawSplit","getBestVersionForData","fromString","Error","bestVersion","dataBits","moduleCount","getSymbolSize","modules","isNaN","getBestMask","bind","applyMask","exports","create","options","M","mask","from","toSJISFunc","setToSJISFunction"],"mappings":"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","sourcesContent":["const Utils = require('./utils')\nconst ECLevel = require('./error-correction-level')\nconst BitBuffer = require('./bit-buffer')\nconst BitMatrix = require('./bit-matrix')\nconst AlignmentPattern = require('./alignment-pattern')\nconst FinderPattern = require('./finder-pattern')\nconst MaskPattern = require('./mask-pattern')\nconst ECCode = require('./error-correction-code')\nconst ReedSolomonEncoder = require('./reed-solomon-encoder')\nconst Version = require('./version')\nconst FormatInfo = require('./format-info')\nconst Mode = require('./mode')\nconst Segments = require('./segments')\n\n/**\n * QRCode for JavaScript\n *\n * modified by Ryan Day for nodejs support\n * Copyright (c) 2011 Ryan Day\n *\n * Licensed under the MIT license:\n *   http://www.opensource.org/licenses/mit-license.php\n *\n//---------------------------------------------------------------------\n// QRCode for JavaScript\n//\n// Copyright (c) 2009 Kazuhiko Arase\n//\n// URL: http://www.d-project.com/\n//\n// Licensed under the MIT license:\n//   http://www.opensource.org/licenses/mit-license.php\n//\n// The word \"QR Code\" is registered trademark of\n// DENSO WAVE INCORPORATED\n//   http://www.denso-wave.com/qrcode/faqpatent-e.html\n//\n//---------------------------------------------------------------------\n*/\n\n/**\n * Add finder patterns bits to matrix\n *\n * @param  {BitMatrix} matrix  Modules matrix\n * @param  {Number}    version QR Code version\n */\nfunction setupFinderPattern (matrix, version) {\n  const size = matrix.size\n  const pos = FinderPattern.getPositions(version)\n\n  for (let i = 0; i < pos.length; i++) {\n    const row = pos[i][0]\n    const col = pos[i][1]\n\n    for (let r = -1; r <= 7; r++) {\n      if (row + r <= -1 || size <= row + r) continue\n\n      for (let c = -1; c <= 7; c++) {\n        if (col + c <= -1 || size <= col + c) continue\n\n        if ((r >= 0 && r <= 6 && (c === 0 || c === 6)) ||\n          (c >= 0 && c <= 6 && (r === 0 || r === 6)) ||\n          (r >= 2 && r <= 4 && c >= 2 && c <= 4)) {\n          matrix.set(row + r, col + c, true, true)\n        } else {\n          matrix.set(row + r, col + c, false, true)\n        }\n      }\n    }\n  }\n}\n\n/**\n * Add timing pattern bits to matrix\n *\n * Note: this function must be called before {@link setupAlignmentPattern}\n *\n * @param  {BitMatrix} matrix Modules matrix\n */\nfunction setupTimingPattern (matrix) {\n  const size = matrix.size\n\n  for (let r = 8; r < size - 8; r++) {\n    const value = r % 2 === 0\n    matrix.set(r, 6, value, true)\n    matrix.set(6, r, value, true)\n  }\n}\n\n/**\n * Add alignment patterns bits to matrix\n *\n * Note: this function must be called after {@link setupTimingPattern}\n *\n * @param  {BitMatrix} matrix  Modules matrix\n * @param  {Number}    version QR Code version\n */\nfunction setupAlignmentPattern (matrix, version) {\n  const pos = AlignmentPattern.getPositions(version)\n\n  for (let i = 0; i < pos.length; i++) {\n    const row = pos[i][0]\n    const col = pos[i][1]\n\n    for (let r = -2; r <= 2; r++) {\n      for (let c = -2; c <= 2; c++) {\n        if (r === -2 || r === 2 || c === -2 || c === 2 ||\n          (r === 0 && c === 0)) {\n          matrix.set(row + r, col + c, true, true)\n        } else {\n          matrix.set(row + r, col + c, false, true)\n        }\n      }\n    }\n  }\n}\n\n/**\n * Add version info bits to matrix\n *\n * @param  {BitMatrix} matrix  Modules matrix\n * @param  {Number}    version QR Code version\n */\nfunction setupVersionInfo (matrix, version) {\n  const size = matrix.size\n  const bits = Version.getEncodedBits(version)\n  let row, col, mod\n\n  for (let i = 0; i < 18; i++) {\n    row = Math.floor(i / 3)\n    col = i % 3 + size - 8 - 3\n    mod = ((bits >> i) & 1) === 1\n\n    matrix.set(row, col, mod, true)\n    matrix.set(col, row, mod, true)\n  }\n}\n\n/**\n * Add format info bits to matrix\n *\n * @param  {BitMatrix} matrix               Modules matrix\n * @param  {ErrorCorrectionLevel}    errorCorrectionLevel Error correction level\n * @param  {Number}    maskPattern          Mask pattern reference value\n */\nfunction setupFormatInfo (matrix, errorCorrectionLevel, maskPattern) {\n  const size = matrix.size\n  const bits = FormatInfo.getEncodedBits(errorCorrectionLevel, maskPattern)\n  let i, mod\n\n  for (i = 0; i < 15; i++) {\n    mod = ((bits >> i) & 1) === 1\n\n    // vertical\n    if (i < 6) {\n      matrix.set(i, 8, mod, true)\n    } else if (i < 8) {\n      matrix.set(i + 1, 8, mod, true)\n    } else {\n      matrix.set(size - 15 + i, 8, mod, true)\n    }\n\n    // horizontal\n    if (i < 8) {\n      matrix.set(8, size - i - 1, mod, true)\n    } else if (i < 9) {\n      matrix.set(8, 15 - i - 1 + 1, mod, true)\n    } else {\n      matrix.set(8, 15 - i - 1, mod, true)\n    }\n  }\n\n  // fixed module\n  matrix.set(size - 8, 8, 1, true)\n}\n\n/**\n * Add encoded data bits to matrix\n *\n * @param  {BitMatrix}  matrix Modules matrix\n * @param  {Uint8Array} data   Data codewords\n */\nfunction setupData (matrix, data) {\n  const size = matrix.size\n  let inc = -1\n  let row = size - 1\n  let bitIndex = 7\n  let byteIndex = 0\n\n  for (let col = size - 1; col > 0; col -= 2) {\n    if (col === 6) col--\n\n    while (true) {\n      for (let c = 0; c < 2; c++) {\n        if (!matrix.isReserved(row, col - c)) {\n          let dark = false\n\n          if (byteIndex < data.length) {\n            dark = (((data[byteIndex] >>> bitIndex) & 1) === 1)\n          }\n\n          matrix.set(row, col - c, dark)\n          bitIndex--\n\n          if (bitIndex === -1) {\n            byteIndex++\n            bitIndex = 7\n          }\n        }\n      }\n\n      row += inc\n\n      if (row < 0 || size <= row) {\n        row -= inc\n        inc = -inc\n        break\n      }\n    }\n  }\n}\n\n/**\n * Create encoded codewords from data input\n *\n * @param  {Number}   version              QR Code version\n * @param  {ErrorCorrectionLevel}   errorCorrectionLevel Error correction level\n * @param  {ByteData} data                 Data input\n * @return {Uint8Array}                    Buffer containing encoded codewords\n */\nfunction createData (version, errorCorrectionLevel, segments) {\n  // Prepare data buffer\n  const buffer = new BitBuffer()\n\n  segments.forEach(function (data) {\n    // prefix data with mode indicator (4 bits)\n    buffer.put(data.mode.bit, 4)\n\n    // Prefix data with character count indicator.\n    // The character count indicator is a string of bits that represents the\n    // number of characters that are being encoded.\n    // The character count indicator must be placed after the mode indicator\n    // and must be a certain number of bits long, depending on the QR version\n    // and data mode\n    // @see {@link Mode.getCharCountIndicator}.\n    buffer.put(data.getLength(), Mode.getCharCountIndicator(data.mode, version))\n\n    // add binary data sequence to buffer\n    data.write(buffer)\n  })\n\n  // Calculate required number of bits\n  const totalCodewords = Utils.getSymbolTotalCodewords(version)\n  const ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel)\n  const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8\n\n  // Add a terminator.\n  // If the bit string is shorter than the total number of required bits,\n  // a terminator of up to four 0s must be added to the right side of the string.\n  // If the bit string is more than four bits shorter than the required number of bits,\n  // add four 0s to the end.\n  if (buffer.getLengthInBits() + 4 <= dataTotalCodewordsBits) {\n    buffer.put(0, 4)\n  }\n\n  // If the bit string is fewer than four bits shorter, add only the number of 0s that\n  // are needed to reach the required number of bits.\n\n  // After adding the terminator, if the number of bits in the string is not a multiple of 8,\n  // pad the string on the right with 0s to make the string's length a multiple of 8.\n  while (buffer.getLengthInBits() % 8 !== 0) {\n    buffer.putBit(0)\n  }\n\n  // Add pad bytes if the string is still shorter than the total number of required bits.\n  // Extend the buffer to fill the data capacity of the symbol corresponding to\n  // the Version and Error Correction Level by adding the Pad Codewords 11101100 (0xEC)\n  // and 00010001 (0x11) alternately.\n  const remainingByte = (dataTotalCodewordsBits - buffer.getLengthInBits()) / 8\n  for (let i = 0; i < remainingByte; i++) {\n    buffer.put(i % 2 ? 0x11 : 0xEC, 8)\n  }\n\n  return createCodewords(buffer, version, errorCorrectionLevel)\n}\n\n/**\n * Encode input data with Reed-Solomon and return codewords with\n * relative error correction bits\n *\n * @param  {BitBuffer} bitBuffer            Data to encode\n * @param  {Number}    version              QR Code version\n * @param  {ErrorCorrectionLevel} errorCorrectionLevel Error correction level\n * @return {Uint8Array}                     Buffer containing encoded codewords\n */\nfunction createCodewords (bitBuffer, version, errorCorrectionLevel) {\n  // Total codewords for this QR code version (Data + Error correction)\n  const totalCodewords = Utils.getSymbolTotalCodewords(version)\n\n  // Total number of error correction codewords\n  const ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel)\n\n  // Total number of data codewords\n  const dataTotalCodewords = totalCodewords - ecTotalCodewords\n\n  // Total number of blocks\n  const ecTotalBlocks = ECCode.getBlocksCount(version, errorCorrectionLevel)\n\n  // Calculate how many blocks each group should contain\n  const blocksInGroup2 = totalCodewords % ecTotalBlocks\n  const blocksInGroup1 = ecTotalBlocks - blocksInGroup2\n\n  const totalCodewordsInGroup1 = Math.floor(totalCodewords / ecTotalBlocks)\n\n  const dataCodewordsInGroup1 = Math.floor(dataTotalCodewords / ecTotalBlocks)\n  const dataCodewordsInGroup2 = dataCodewordsInGroup1 + 1\n\n  // Number of EC codewords is the same for both groups\n  const ecCount = totalCodewordsInGroup1 - dataCodewordsInGroup1\n\n  // Initialize a Reed-Solomon encoder with a generator polynomial of degree ecCount\n  const rs = new ReedSolomonEncoder(ecCount)\n\n  let offset = 0\n  const dcData = new Array(ecTotalBlocks)\n  const ecData = new Array(ecTotalBlocks)\n  let maxDataSize = 0\n  const buffer = new Uint8Array(bitBuffer.buffer)\n\n  // Divide the buffer into the required number of blocks\n  for (let b = 0; b < ecTotalBlocks; b++) {\n    const dataSize = b < blocksInGroup1 ? dataCodewordsInGroup1 : dataCodewordsInGroup2\n\n    // extract a block of data from buffer\n    dcData[b] = buffer.slice(offset, offset + dataSize)\n\n    // Calculate EC codewords for this data block\n    ecData[b] = rs.encode(dcData[b])\n\n    offset += dataSize\n    maxDataSize = Math.max(maxDataSize, dataSize)\n  }\n\n  // Create final data\n  // Interleave the data and error correction codewords from each block\n  const data = new Uint8Array(totalCodewords)\n  let index = 0\n  let i, r\n\n  // Add data codewords\n  for (i = 0; i < maxDataSize; i++) {\n    for (r = 0; r < ecTotalBlocks; r++) {\n      if (i < dcData[r].length) {\n        data[index++] = dcData[r][i]\n      }\n    }\n  }\n\n  // Apped EC codewords\n  for (i = 0; i < ecCount; i++) {\n    for (r = 0; r < ecTotalBlocks; r++) {\n      data[index++] = ecData[r][i]\n    }\n  }\n\n  return data\n}\n\n/**\n * Build QR Code symbol\n *\n * @param  {String} data                 Input string\n * @param  {Number} version              QR Code version\n * @param  {ErrorCorretionLevel} errorCorrectionLevel Error level\n * @param  {MaskPattern} maskPattern     Mask pattern\n * @return {Object}                      Object containing symbol data\n */\nfunction createSymbol (data, version, errorCorrectionLevel, maskPattern) {\n  let segments\n\n  if (Array.isArray(data)) {\n    segments = Segments.fromArray(data)\n  } else if (typeof data === 'string') {\n    let estimatedVersion = version\n\n    if (!estimatedVersion) {\n      const rawSegments = Segments.rawSplit(data)\n\n      // Estimate best version that can contain raw splitted segments\n      estimatedVersion = Version.getBestVersionForData(rawSegments, errorCorrectionLevel)\n    }\n\n    // Build optimized segments\n    // If estimated version is undefined, try with the highest version\n    segments = Segments.fromString(data, estimatedVersion || 40)\n  } else {\n    throw new Error('Invalid data')\n  }\n\n  // Get the min version that can contain data\n  const bestVersion = Version.getBestVersionForData(segments, errorCorrectionLevel)\n\n  // If no version is found, data cannot be stored\n  if (!bestVersion) {\n    throw new Error('The amount of data is too big to be stored in a QR Code')\n  }\n\n  // If not specified, use min version as default\n  if (!version) {\n    version = bestVersion\n\n  // Check if the specified version can contain the data\n  } else if (version < bestVersion) {\n    throw new Error('\\n' +\n      'The chosen QR Code version cannot contain this amount of data.\\n' +\n      'Minimum version required to store current data is: ' + bestVersion + '.\\n'\n    )\n  }\n\n  const dataBits = createData(version, errorCorrectionLevel, segments)\n\n  // Allocate matrix buffer\n  const moduleCount = Utils.getSymbolSize(version)\n  const modules = new BitMatrix(moduleCount)\n\n  // Add function modules\n  setupFinderPattern(modules, version)\n  setupTimingPattern(modules)\n  setupAlignmentPattern(modules, version)\n\n  // Add temporary dummy bits for format info just to set them as reserved.\n  // This is needed to prevent these bits from being masked by {@link MaskPattern.applyMask}\n  // since the masking operation must be performed only on the encoding region.\n  // These blocks will be replaced with correct values later in code.\n  setupFormatInfo(modules, errorCorrectionLevel, 0)\n\n  if (version >= 7) {\n    setupVersionInfo(modules, version)\n  }\n\n  // Add data codewords\n  setupData(modules, dataBits)\n\n  if (isNaN(maskPattern)) {\n    // Find best mask pattern\n    maskPattern = MaskPattern.getBestMask(modules,\n      setupFormatInfo.bind(null, modules, errorCorrectionLevel))\n  }\n\n  // Apply mask pattern\n  MaskPattern.applyMask(maskPattern, modules)\n\n  // Replace format info bits with correct values\n  setupFormatInfo(modules, errorCorrectionLevel, maskPattern)\n\n  return {\n    modules: modules,\n    version: version,\n    errorCorrectionLevel: errorCorrectionLevel,\n    maskPattern: maskPattern,\n    segments: segments\n  }\n}\n\n/**\n * QR Code\n *\n * @param {String | Array} data                 Input data\n * @param {Object} options                      Optional configurations\n * @param {Number} options.version              QR Code version\n * @param {String} options.errorCorrectionLevel Error correction level\n * @param {Function} options.toSJISFunc         Helper func to convert utf8 to sjis\n */\nexports.create = function create (data, options) {\n  if (typeof data === 'undefined' || data === '') {\n    throw new Error('No input text')\n  }\n\n  let errorCorrectionLevel = ECLevel.M\n  let version\n  let mask\n\n  if (typeof options !== 'undefined') {\n    // Use higher error correction level as default\n    errorCorrectionLevel = ECLevel.from(options.errorCorrectionLevel, ECLevel.M)\n    version = Version.from(options.version)\n    mask = MaskPattern.from(options.maskPattern)\n\n    if (options.toSJISFunc) {\n      Utils.setToSJISFunction(options.toSJISFunc)\n    }\n  }\n\n  return createSymbol(data, version, errorCorrectionLevel, mask)\n}\n"]},"metadata":{},"sourceType":"script"}