{"ast":null,"code":"const iconv = require('iconv-lite');\n\nconst linewrap = require('linewrap');\n\nconst {\n  createCanvas\n} = require('canvas');\n\nconst Dither = require('canvas-dither');\n\nconst Flatten = require('canvas-flatten');\n/**\n * Create a byte stream based on commands for ESC/POS printers\n */\n\n\nclass EscPosEncoder {\n  /**\n     * Create a new object\n     *\n    */\n  constructor() {\n    this._reset();\n  }\n  /**\n     * Reset the state of the object\n     *\n    */\n\n\n  _reset() {\n    this._buffer = [];\n    this._codepage = 'ascii';\n    this._state = {\n      'bold': false,\n      'italic': false,\n      'underline': false,\n      'hanzi': false\n    };\n  }\n  /**\n     * Encode a string with the current code page\n     *\n     * @param  {string}   value  String to encode\n     * @return {object}          Encoded string as a ArrayBuffer\n     *\n    */\n\n\n  _encode(value) {\n    return iconv.encode(value, this._codepage);\n  }\n  /**\n     * Add commands to the buffer\n     *\n     * @param  {array}   value  And array of numbers, arrays, buffers or Uint8Arrays to add to the buffer\n     *\n    */\n\n\n  _queue(value) {\n    value.forEach(item => this._buffer.push(item));\n  }\n  /**\n     * Initialize the printer\n     *\n     * @return {object}          Return the object, for easy chaining commands\n     *\n     */\n\n\n  initialize() {\n    this._queue([0x1b, 0x40]);\n\n    return this;\n  }\n  /**\n     * Change the code page\n     *\n     * @param  {string}   value  The codepage that we set the printer to\n     * @return {object}          Return the object, for easy chaining commands\n     *\n     */\n\n\n  codepage(value) {\n    const codepages = {\n      'cp437': [0x00, false],\n      'cp737': [0x40, false],\n      'cp850': [0x02, false],\n      'cp775': [0x5f, false],\n      'cp852': [0x12, false],\n      'cp855': [0x3c, false],\n      'cp857': [0x3d, false],\n      'cp858': [0x13, false],\n      'cp860': [0x03, false],\n      'cp861': [0x38, false],\n      'cp862': [0x3e, false],\n      'cp863': [0x04, false],\n      'cp864': [0x1c, false],\n      'cp865': [0x05, false],\n      'cp866': [0x11, false],\n      'cp869': [0x42, false],\n      'cp936': [0xff, true],\n      'cp949': [0xfd, true],\n      'cp950': [0xfe, true],\n      'cp1252': [0x10, false],\n      'iso88596': [0x16, false],\n      'shiftjis': [0xfc, true],\n      'windows874': [0x1e, false],\n      'windows1250': [0x48, false],\n      'windows1251': [0x49, false],\n      'windows1252': [0x47, false],\n      'windows1253': [0x5a, false],\n      'windows1254': [0x5b, false],\n      'windows1255': [0x20, false],\n      'windows1256': [0x5c, false],\n      'windows1257': [0x19, false],\n      'windows1258': [0x5e, false]\n    };\n    let codepage;\n\n    if (!iconv.encodingExists(value)) {\n      throw new Error('Unknown codepage');\n    }\n\n    if (value in iconv.encodings) {\n      if (typeof iconv.encodings[value] === 'string') {\n        codepage = iconv.encodings[value];\n      } else {\n        codepage = value;\n      }\n    } else {\n      throw new Error('Unknown codepage');\n    }\n\n    if (typeof codepages[codepage] !== 'undefined') {\n      this._codepage = codepage;\n      this._state.hanzi = codepages[codepage][1];\n\n      this._queue([0x1b, 0x74, codepages[codepage][0]]);\n    } else {\n      throw new Error('Codepage not supported by printer');\n    }\n\n    return this;\n  }\n  /**\n     * Print text\n     *\n     * @param  {string}   value  Text that needs to be printed\n     * @param  {number}   wrap   Wrap text after this many positions\n     * @return {object}          Return the object, for easy chaining commands\n     *\n     */\n\n\n  text(value, wrap) {\n    if (wrap) {\n      const w = linewrap(wrap, {\n        lineBreak: '\\r\\n'\n      });\n      value = w(value);\n    }\n\n    const bytes = this._encode(value);\n\n    if (this._state.hanzi) {\n      this._queue([0x1c, 0x26, bytes, 0x1c, 0x2e]);\n    } else {\n      this._queue([bytes]);\n    }\n\n    return this;\n  }\n  /**\n     * Print a newline\n     *\n     * @return {object}          Return the object, for easy chaining commands\n     *\n     */\n\n\n  newline() {\n    this._queue([0x0a, 0x0d]);\n\n    return this;\n  }\n  /**\n     * Print text, followed by a newline\n     *\n     * @param  {string}   value  Text that needs to be printed\n     * @param  {number}   wrap   Wrap text after this many positions\n     * @return {object}          Return the object, for easy chaining commands\n     *\n     */\n\n\n  line(value, wrap) {\n    this.text(value, wrap);\n    this.newline();\n    return this;\n  }\n  /**\n     * Underline text\n     *\n     * @param  {boolean|number}   value  true to turn on underline, false to turn off, or 2 for double underline\n     * @return {object}                  Return the object, for easy chaining commands\n     *\n     */\n\n\n  underline(value) {\n    if (typeof value === 'undefined') {\n      value = !this._state.underline;\n    }\n\n    this._state.underline = value;\n\n    this._queue([0x1b, 0x2d, Number(value)]);\n\n    return this;\n  }\n  /**\n     * Italic text\n     *\n     * @param  {boolean}          value  true to turn on italic, false to turn off\n     * @return {object}                  Return the object, for easy chaining commands\n     *\n     */\n\n\n  italic(value) {\n    if (typeof value === 'undefined') {\n      value = !this._state.italic;\n    }\n\n    this._state.italic = value;\n\n    this._queue([0x1b, 0x34, Number(value)]);\n\n    return this;\n  }\n  /**\n     * Bold text\n     *\n     * @param  {boolean}          value  true to turn on bold, false to turn off, or 2 for double underline\n     * @return {object}                  Return the object, for easy chaining commands\n     *\n     */\n\n\n  bold(value) {\n    if (typeof value === 'undefined') {\n      value = !this._state.bold;\n    }\n\n    this._state.bold = value;\n\n    this._queue([0x1b, 0x45, Number(value)]);\n\n    return this;\n  }\n  /**\n     * Change text size\n     *\n     * @param  {string}          value   small or normal\n     * @return {object}                  Return the object, for easy chaining commands\n     *\n     */\n\n\n  size(value) {\n    if (value === 'small') {\n      value = 0x01;\n    } else {\n      value = 0x00;\n    }\n\n    this._queue([0x1b, 0x4d, value]);\n\n    return this;\n  }\n  /**\n     * Change text alignment\n     *\n     * @param  {string}          value   left, center or right\n     * @return {object}                  Return the object, for easy chaining commands\n     *\n     */\n\n\n  align(value) {\n    const alignments = {\n      'left': 0x00,\n      'center': 0x01,\n      'right': 0x02\n    };\n\n    if (value in alignments) {\n      this._queue([0x1b, 0x61, alignments[value]]);\n    } else {\n      throw new Error('Unknown alignment');\n    }\n\n    return this;\n  }\n  /**\n     * Barcode\n     *\n     * @param  {string}           value  the value of the barcode\n     * @param  {string}           symbology  the type of the barcode\n     * @param  {number}           height  height of the barcode\n     * @return {object}                  Return the object, for easy chaining commands\n     *\n     */\n\n\n  barcode(value, symbology, height) {\n    const symbologies = {\n      'upca': 0x00,\n      'upce': 0x01,\n      'ean13': 0x02,\n      'ean8': 0x03,\n      'code39': 0x04,\n      'coda39': 0x04,\n\n      /* typo, leave here for backwards compatibility */\n      'itf': 0x05,\n      'codabar': 0x06,\n      'code93': 0x48,\n      'code128': 0x49,\n      'gs1-128': 0x50,\n      'gs1-databar-omni': 0x51,\n      'gs1-databar-truncated': 0x52,\n      'gs1-databar-limited': 0x53,\n      'gs1-databar-expanded': 0x54,\n      'code128-auto': 0x55\n    };\n\n    if (symbology in symbologies) {\n      const bytes = iconv.encode(value, 'ascii');\n\n      this._queue([0x1d, 0x68, height, 0x1d, 0x77, symbology === 'code39' ? 0x02 : 0x03]);\n\n      if (symbology == 'code128' && bytes[0] !== 0x7b) {\n        /* Not yet encodeded Code 128, assume data is Code B, which is similar to ASCII without control chars */\n        this._queue([0x1d, 0x6b, symbologies[symbology], bytes.length + 2, 0x7b, 0x42, bytes]);\n      } else if (symbologies[symbology] > 0x40) {\n        /* Function B symbologies */\n        this._queue([0x1d, 0x6b, symbologies[symbology], bytes.length, bytes]);\n      } else {\n        /* Function A symbologies */\n        this._queue([0x1d, 0x6b, symbologies[symbology], bytes, 0x00]);\n      }\n    } else {\n      throw new Error('Symbology not supported by printer');\n    }\n\n    return this;\n  }\n  /**\n     * QR code\n     *\n     * @param  {string}           value  the value of the qr code\n     * @param  {number}           model  model of the qrcode, either 1 or 2\n     * @param  {number}           size   size of the qrcode, a value between 1 and 8\n     * @param  {string}           errorlevel  the amount of error correction used, either 'l', 'm', 'q', 'h'\n     * @return {object}                  Return the object, for easy chaining commands\n     *\n     */\n\n\n  qrcode(value, model, size, errorlevel) {\n    /* Force printing the print buffer and moving to a new line */\n    this._queue([0x0a]);\n    /* Model */\n\n\n    const models = {\n      1: 0x31,\n      2: 0x32\n    };\n\n    if (typeof model === 'undefined') {\n      model = 2;\n    }\n\n    if (model in models) {\n      this._queue([0x1d, 0x28, 0x6b, 0x04, 0x00, 0x31, 0x41, models[model], 0x00]);\n    } else {\n      throw new Error('Model must be 1 or 2');\n    }\n    /* Size */\n\n\n    if (typeof size === 'undefined') {\n      size = 6;\n    }\n\n    if (typeof size !== 'number') {\n      throw new Error('Size must be a number');\n    }\n\n    if (size < 1 || size > 8) {\n      throw new Error('Size must be between 1 and 8');\n    }\n\n    this._queue([0x1d, 0x28, 0x6b, 0x03, 0x00, 0x31, 0x43, size]);\n    /* Error level */\n\n\n    const errorlevels = {\n      'l': 0x30,\n      'm': 0x31,\n      'q': 0x32,\n      'h': 0x33\n    };\n\n    if (typeof errorlevel === 'undefined') {\n      errorlevel = 'm';\n    }\n\n    if (errorlevel in errorlevels) {\n      this._queue([0x1d, 0x28, 0x6b, 0x03, 0x00, 0x31, 0x45, errorlevels[errorlevel]]);\n    } else {\n      throw new Error('Error level must be l, m, q or h');\n    }\n    /* Data */\n\n\n    const bytes = iconv.encode(value, 'iso88591');\n    const length = bytes.length + 3;\n\n    this._queue([0x1d, 0x28, 0x6b, length % 0xff, length / 0xff, 0x31, 0x50, 0x30, bytes]);\n    /* Print QR code */\n\n\n    this._queue([0x1d, 0x28, 0x6b, 0x03, 0x00, 0x31, 0x51, 0x30]);\n\n    return this;\n  }\n  /**\n     * Image\n     *\n     * @param  {object}         element  an element, like a canvas or image that needs to be printed\n     * @param  {number}         width  width of the image on the printer\n     * @param  {number}         height  height of the image on the printer\n     * @param  {string}         algorithm  the dithering algorithm for making the image black and white\n     * @param  {number}         threshold  threshold for the dithering algorithm\n     * @return {object}                  Return the object, for easy chaining commands\n     *\n     */\n\n\n  image(element, width, height, algorithm, threshold) {\n    if (width % 8 !== 0) {\n      throw new Error('Width must be a multiple of 8');\n    }\n\n    if (height % 8 !== 0) {\n      throw new Error('Height must be a multiple of 8');\n    }\n\n    if (typeof algorithm === 'undefined') {\n      algorithm = 'threshold';\n    }\n\n    if (typeof threshold === 'undefined') {\n      threshold = 128;\n    }\n\n    const canvas = createCanvas(width, height);\n    const context = canvas.getContext('2d');\n    context.drawImage(element, 0, 0, width, height);\n    let image = context.getImageData(0, 0, width, height);\n    image = Flatten.flatten(image, [0xff, 0xff, 0xff]);\n\n    switch (algorithm) {\n      case 'threshold':\n        image = Dither.threshold(image, threshold);\n        break;\n\n      case 'bayer':\n        image = Dither.bayer(image, threshold);\n        break;\n\n      case 'floydsteinberg':\n        image = Dither.floydsteinberg(image);\n        break;\n\n      case 'atkinson':\n        image = Dither.atkinson(image);\n        break;\n    }\n\n    const getPixel = (x, y) => image.data[(width * y + x) * 4] > 0 ? 0 : 1;\n\n    const bytes = new Uint8Array(width * height >> 3);\n\n    for (let y = 0; y < height; y++) {\n      for (let x = 0; x < width; x = x + 8) {\n        const i = y * (width >> 3) + (x >> 3);\n        bytes[i] = getPixel(x + 0, y) << 7 | getPixel(x + 1, y) << 6 | getPixel(x + 2, y) << 5 | getPixel(x + 3, y) << 4 | getPixel(x + 4, y) << 3 | getPixel(x + 5, y) << 2 | getPixel(x + 6, y) << 1 | getPixel(x + 7, y);\n      }\n    }\n\n    this._queue([0x1d, 0x76, 0x30, 0x00, width >> 3 & 0xff, width >> 3 >> 8 & 0xff, height & 0xff, height >> 8 & 0xff, bytes]);\n\n    return this;\n  }\n  /**\n     * Cut paper\n     *\n     * @param  {string}          value   full or partial. When not specified a full cut will be assumed\n     * @return {object}                  Return the object, for easy chaining commands\n     *\n     */\n\n\n  cut(value) {\n    let data = 0x00;\n\n    if (value == 'partial') {\n      data = 0x01;\n    }\n\n    this._queue([0x1d, 0x56, data]);\n\n    return this;\n  }\n  /**\n     * Add raw printer commands\n     *\n     * @param  {array}           data   raw bytes to be included\n     * @return {object}          Return the object, for easy chaining commands\n     *\n     */\n\n\n  raw(data) {\n    this._queue(data);\n\n    return this;\n  }\n  /**\n     * Encode all previous commands\n     *\n     * @return {Uint8Array}         Return the encoded bytes\n     *\n     */\n\n\n  encode() {\n    let length = 0;\n\n    this._buffer.forEach(item => {\n      if (typeof item === 'number') {\n        length++;\n      } else {\n        length += item.length;\n      }\n    });\n\n    const result = new Uint8Array(length);\n    let index = 0;\n\n    this._buffer.forEach(item => {\n      if (typeof item === 'number') {\n        result[index] = item;\n        index++;\n      } else {\n        result.set(item, index);\n        index += item.length;\n      }\n    });\n\n    this._reset();\n\n    return result;\n  }\n\n}\n\nmodule.exports = EscPosEncoder;","map":{"version":3,"sources":["/Users/sirin/go/src/github.com/sirinibin/reactjs-pos/node_modules/esc-pos-encoder/src/esc-pos-encoder.js"],"names":["iconv","require","linewrap","createCanvas","Dither","Flatten","EscPosEncoder","constructor","_reset","_buffer","_codepage","_state","_encode","value","encode","_queue","forEach","item","push","initialize","codepage","codepages","encodingExists","Error","encodings","hanzi","text","wrap","w","lineBreak","bytes","newline","line","underline","Number","italic","bold","size","align","alignments","barcode","symbology","height","symbologies","length","qrcode","model","errorlevel","models","errorlevels","image","element","width","algorithm","threshold","canvas","context","getContext","drawImage","getImageData","flatten","bayer","floydsteinberg","atkinson","getPixel","x","y","data","Uint8Array","i","cut","raw","result","index","set","module","exports"],"mappings":"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","sourcesContent":["const iconv = require('iconv-lite');\nconst linewrap = require('linewrap');\nconst {createCanvas} = require('canvas');\nconst Dither = require('canvas-dither');\nconst Flatten = require('canvas-flatten');\n\n\n/**\n * Create a byte stream based on commands for ESC/POS printers\n */\nclass EscPosEncoder {\n  /**\n     * Create a new object\n     *\n    */\n  constructor() {\n    this._reset();\n  }\n\n  /**\n     * Reset the state of the object\n     *\n    */\n  _reset() {\n    this._buffer = [];\n    this._codepage = 'ascii';\n\n    this._state = {\n      'bold': false,\n      'italic': false,\n      'underline': false,\n      'hanzi': false,\n    };\n  }\n\n  /**\n     * Encode a string with the current code page\n     *\n     * @param  {string}   value  String to encode\n     * @return {object}          Encoded string as a ArrayBuffer\n     *\n    */\n  _encode(value) {\n    return iconv.encode(value, this._codepage);\n  }\n\n  /**\n     * Add commands to the buffer\n     *\n     * @param  {array}   value  And array of numbers, arrays, buffers or Uint8Arrays to add to the buffer\n     *\n    */\n  _queue(value) {\n    value.forEach((item) => this._buffer.push(item));\n  }\n\n  /**\n     * Initialize the printer\n     *\n     * @return {object}          Return the object, for easy chaining commands\n     *\n     */\n  initialize() {\n    this._queue([\n      0x1b, 0x40,\n    ]);\n\n    return this;\n  }\n\n  /**\n     * Change the code page\n     *\n     * @param  {string}   value  The codepage that we set the printer to\n     * @return {object}          Return the object, for easy chaining commands\n     *\n     */\n  codepage(value) {\n    const codepages = {\n      'cp437': [0x00, false],\n      'cp737': [0x40, false],\n      'cp850': [0x02, false],\n      'cp775': [0x5f, false],\n      'cp852': [0x12, false],\n      'cp855': [0x3c, false],\n      'cp857': [0x3d, false],\n      'cp858': [0x13, false],\n      'cp860': [0x03, false],\n      'cp861': [0x38, false],\n      'cp862': [0x3e, false],\n      'cp863': [0x04, false],\n      'cp864': [0x1c, false],\n      'cp865': [0x05, false],\n      'cp866': [0x11, false],\n      'cp869': [0x42, false],\n      'cp936': [0xff, true],\n      'cp949': [0xfd, true],\n      'cp950': [0xfe, true],\n      'cp1252': [0x10, false],\n      'iso88596': [0x16, false],\n      'shiftjis': [0xfc, true],\n      'windows874': [0x1e, false],\n      'windows1250': [0x48, false],\n      'windows1251': [0x49, false],\n      'windows1252': [0x47, false],\n      'windows1253': [0x5a, false],\n      'windows1254': [0x5b, false],\n      'windows1255': [0x20, false],\n      'windows1256': [0x5c, false],\n      'windows1257': [0x19, false],\n      'windows1258': [0x5e, false],\n    };\n\n    let codepage;\n\n    if (!iconv.encodingExists(value)) {\n      throw new Error('Unknown codepage');\n    }\n\n    if (value in iconv.encodings) {\n      if (typeof iconv.encodings[value] === 'string') {\n        codepage = iconv.encodings[value];\n      } else {\n        codepage = value;\n      }\n    } else {\n      throw new Error('Unknown codepage');\n    }\n\n    if (typeof codepages[codepage] !== 'undefined') {\n      this._codepage = codepage;\n      this._state.hanzi = codepages[codepage][1];\n\n      this._queue([\n        0x1b, 0x74, codepages[codepage][0],\n      ]);\n    } else {\n      throw new Error('Codepage not supported by printer');\n    }\n\n    return this;\n  }\n\n  /**\n     * Print text\n     *\n     * @param  {string}   value  Text that needs to be printed\n     * @param  {number}   wrap   Wrap text after this many positions\n     * @return {object}          Return the object, for easy chaining commands\n     *\n     */\n  text(value, wrap) {\n    if (wrap) {\n      const w = linewrap(wrap, {lineBreak: '\\r\\n'});\n      value = w(value);\n    }\n\n    const bytes = this._encode(value);\n\n    if (this._state.hanzi) {\n      this._queue([\n        0x1c, 0x26, bytes, 0x1c, 0x2e,\n      ]);\n    } else {\n      this._queue([\n        bytes,\n      ]);\n    }\n\n    return this;\n  }\n\n  /**\n     * Print a newline\n     *\n     * @return {object}          Return the object, for easy chaining commands\n     *\n     */\n  newline() {\n    this._queue([\n      0x0a, 0x0d,\n    ]);\n\n    return this;\n  }\n\n  /**\n     * Print text, followed by a newline\n     *\n     * @param  {string}   value  Text that needs to be printed\n     * @param  {number}   wrap   Wrap text after this many positions\n     * @return {object}          Return the object, for easy chaining commands\n     *\n     */\n  line(value, wrap) {\n    this.text(value, wrap);\n    this.newline();\n\n    return this;\n  }\n\n  /**\n     * Underline text\n     *\n     * @param  {boolean|number}   value  true to turn on underline, false to turn off, or 2 for double underline\n     * @return {object}                  Return the object, for easy chaining commands\n     *\n     */\n  underline(value) {\n    if (typeof value === 'undefined') {\n      value = ! this._state.underline;\n    }\n\n    this._state.underline = value;\n\n    this._queue([\n      0x1b, 0x2d, Number(value),\n    ]);\n\n    return this;\n  }\n\n  /**\n     * Italic text\n     *\n     * @param  {boolean}          value  true to turn on italic, false to turn off\n     * @return {object}                  Return the object, for easy chaining commands\n     *\n     */\n  italic(value) {\n    if (typeof value === 'undefined') {\n      value = ! this._state.italic;\n    }\n\n    this._state.italic = value;\n\n    this._queue([\n      0x1b, 0x34, Number(value),\n    ]);\n\n    return this;\n  }\n\n  /**\n     * Bold text\n     *\n     * @param  {boolean}          value  true to turn on bold, false to turn off, or 2 for double underline\n     * @return {object}                  Return the object, for easy chaining commands\n     *\n     */\n  bold(value) {\n    if (typeof value === 'undefined') {\n      value = ! this._state.bold;\n    }\n\n    this._state.bold = value;\n\n    this._queue([\n      0x1b, 0x45, Number(value),\n    ]);\n\n    return this;\n  }\n\n  /**\n     * Change text size\n     *\n     * @param  {string}          value   small or normal\n     * @return {object}                  Return the object, for easy chaining commands\n     *\n     */\n  size(value) {\n    if (value === 'small') {\n      value = 0x01;\n    } else {\n      value = 0x00;\n    }\n\n    this._queue([\n      0x1b, 0x4d, value,\n    ]);\n\n    return this;\n  }\n\n  /**\n     * Change text alignment\n     *\n     * @param  {string}          value   left, center or right\n     * @return {object}                  Return the object, for easy chaining commands\n     *\n     */\n  align(value) {\n    const alignments = {\n      'left': 0x00,\n      'center': 0x01,\n      'right': 0x02,\n    };\n\n    if (value in alignments) {\n      this._queue([\n        0x1b, 0x61, alignments[value],\n      ]);\n    } else {\n      throw new Error('Unknown alignment');\n    }\n\n    return this;\n  }\n\n  /**\n     * Barcode\n     *\n     * @param  {string}           value  the value of the barcode\n     * @param  {string}           symbology  the type of the barcode\n     * @param  {number}           height  height of the barcode\n     * @return {object}                  Return the object, for easy chaining commands\n     *\n     */\n  barcode(value, symbology, height) {\n    const symbologies = {\n      'upca': 0x00,\n      'upce': 0x01,\n      'ean13': 0x02,\n      'ean8': 0x03,\n      'code39': 0x04,\n      'coda39': 0x04, /* typo, leave here for backwards compatibility */\n      'itf': 0x05,\n      'codabar': 0x06,\n      'code93': 0x48,\n      'code128': 0x49,\n      'gs1-128': 0x50,\n      'gs1-databar-omni': 0x51,\n      'gs1-databar-truncated': 0x52,\n      'gs1-databar-limited': 0x53,\n      'gs1-databar-expanded': 0x54,\n      'code128-auto': 0x55,\n    };\n\n    if (symbology in symbologies) {\n      const bytes = iconv.encode(value, 'ascii');\n\n      this._queue([\n        0x1d, 0x68, height,\n        0x1d, 0x77, symbology === 'code39' ? 0x02 : 0x03,\n      ]);\n\n      if (symbology == 'code128' && bytes[0] !== 0x7b) {\n        /* Not yet encodeded Code 128, assume data is Code B, which is similar to ASCII without control chars */\n\n        this._queue([\n          0x1d, 0x6b, symbologies[symbology],\n          bytes.length + 2,\n          0x7b, 0x42,\n          bytes,\n        ]);\n      } else if (symbologies[symbology] > 0x40) {\n        /* Function B symbologies */\n\n        this._queue([\n          0x1d, 0x6b, symbologies[symbology],\n          bytes.length,\n          bytes,\n        ]);\n      } else {\n        /* Function A symbologies */\n\n        this._queue([\n          0x1d, 0x6b, symbologies[symbology],\n          bytes,\n          0x00,\n        ]);\n      }\n    } else {\n      throw new Error('Symbology not supported by printer');\n    }\n\n    return this;\n  }\n\n  /**\n     * QR code\n     *\n     * @param  {string}           value  the value of the qr code\n     * @param  {number}           model  model of the qrcode, either 1 or 2\n     * @param  {number}           size   size of the qrcode, a value between 1 and 8\n     * @param  {string}           errorlevel  the amount of error correction used, either 'l', 'm', 'q', 'h'\n     * @return {object}                  Return the object, for easy chaining commands\n     *\n     */\n  qrcode(value, model, size, errorlevel) {\n    /* Force printing the print buffer and moving to a new line */\n\n    this._queue([\n      0x0a,\n    ]);\n\n    /* Model */\n\n    const models = {\n      1: 0x31,\n      2: 0x32,\n    };\n\n    if (typeof model === 'undefined') {\n      model = 2;\n    }\n\n    if (model in models) {\n      this._queue([\n        0x1d, 0x28, 0x6b, 0x04, 0x00, 0x31, 0x41, models[model], 0x00,\n      ]);\n    } else {\n      throw new Error('Model must be 1 or 2');\n    }\n\n    /* Size */\n\n    if (typeof size === 'undefined') {\n      size = 6;\n    }\n\n    if (typeof size !== 'number') {\n      throw new Error('Size must be a number');\n    }\n\n    if (size < 1 || size > 8) {\n      throw new Error('Size must be between 1 and 8');\n    }\n\n    this._queue([\n      0x1d, 0x28, 0x6b, 0x03, 0x00, 0x31, 0x43, size,\n    ]);\n\n    /* Error level */\n\n    const errorlevels = {\n      'l': 0x30,\n      'm': 0x31,\n      'q': 0x32,\n      'h': 0x33,\n    };\n\n    if (typeof errorlevel === 'undefined') {\n      errorlevel = 'm';\n    }\n\n    if (errorlevel in errorlevels) {\n      this._queue([\n        0x1d, 0x28, 0x6b, 0x03, 0x00, 0x31, 0x45, errorlevels[errorlevel],\n      ]);\n    } else {\n      throw new Error('Error level must be l, m, q or h');\n    }\n\n    /* Data */\n\n    const bytes = iconv.encode(value, 'iso88591');\n    const length = bytes.length + 3;\n\n    this._queue([\n      0x1d, 0x28, 0x6b, length % 0xff, length / 0xff, 0x31, 0x50, 0x30, bytes,\n    ]);\n\n    /* Print QR code */\n\n    this._queue([\n      0x1d, 0x28, 0x6b, 0x03, 0x00, 0x31, 0x51, 0x30,\n    ]);\n\n    return this;\n  }\n\n  /**\n     * Image\n     *\n     * @param  {object}         element  an element, like a canvas or image that needs to be printed\n     * @param  {number}         width  width of the image on the printer\n     * @param  {number}         height  height of the image on the printer\n     * @param  {string}         algorithm  the dithering algorithm for making the image black and white\n     * @param  {number}         threshold  threshold for the dithering algorithm\n     * @return {object}                  Return the object, for easy chaining commands\n     *\n     */\n  image(element, width, height, algorithm, threshold) {\n    if (width % 8 !== 0) {\n      throw new Error('Width must be a multiple of 8');\n    }\n\n    if (height % 8 !== 0) {\n      throw new Error('Height must be a multiple of 8');\n    }\n\n    if (typeof algorithm === 'undefined') {\n      algorithm = 'threshold';\n    }\n\n    if (typeof threshold === 'undefined') {\n      threshold = 128;\n    }\n\n    const canvas = createCanvas(width, height);\n    const context = canvas.getContext('2d');\n    context.drawImage(element, 0, 0, width, height);\n    let image = context.getImageData(0, 0, width, height);\n\n    image = Flatten.flatten(image, [0xff, 0xff, 0xff]);\n\n    switch (algorithm) {\n      case 'threshold': image = Dither.threshold(image, threshold); break;\n      case 'bayer': image = Dither.bayer(image, threshold); break;\n      case 'floydsteinberg': image = Dither.floydsteinberg(image); break;\n      case 'atkinson': image = Dither.atkinson(image); break;\n    }\n\n    const getPixel = (x, y) => image.data[((width * y) + x) * 4] > 0 ? 0 : 1;\n\n    const bytes = new Uint8Array((width * height) >> 3);\n\n    for (let y = 0; y < height; y++) {\n      for (let x = 0; x < width; x = x + 8) {\n        const i = (y * (width >> 3)) + (x >> 3);\n        bytes[i] =\n                    getPixel(x + 0, y) << 7 |\n                    getPixel(x + 1, y) << 6 |\n                    getPixel(x + 2, y) << 5 |\n                    getPixel(x + 3, y) << 4 |\n                    getPixel(x + 4, y) << 3 |\n                    getPixel(x + 5, y) << 2 |\n                    getPixel(x + 6, y) << 1 |\n                    getPixel(x + 7, y);\n      }\n    }\n\n    this._queue([\n      0x1d, 0x76, 0x30, 0x00,\n      (width >> 3) & 0xff, (((width >> 3) >> 8) & 0xff),\n      height & 0xff, ((height >> 8) & 0xff),\n      bytes,\n    ]);\n\n    return this;\n  }\n\n  /**\n     * Cut paper\n     *\n     * @param  {string}          value   full or partial. When not specified a full cut will be assumed\n     * @return {object}                  Return the object, for easy chaining commands\n     *\n     */\n  cut(value) {\n    let data = 0x00;\n\n    if (value == 'partial') {\n      data = 0x01;\n    }\n\n    this._queue([\n      0x1d, 0x56, data,\n    ]);\n\n    return this;\n  }\n\n  /**\n     * Add raw printer commands\n     *\n     * @param  {array}           data   raw bytes to be included\n     * @return {object}          Return the object, for easy chaining commands\n     *\n     */\n  raw(data) {\n    this._queue(data);\n\n    return this;\n  }\n\n  /**\n     * Encode all previous commands\n     *\n     * @return {Uint8Array}         Return the encoded bytes\n     *\n     */\n  encode() {\n    let length = 0;\n\n    this._buffer.forEach((item) => {\n      if (typeof item === 'number') {\n        length++;\n      } else {\n        length += item.length;\n      }\n    });\n\n    const result = new Uint8Array(length);\n\n    let index = 0;\n\n    this._buffer.forEach((item) => {\n      if (typeof item === 'number') {\n        result[index] = item;\n        index++;\n      } else {\n        result.set(item, index);\n        index += item.length;\n      }\n    });\n\n    this._reset();\n\n    return result;\n  }\n}\n\nmodule.exports = EscPosEncoder;\n"]},"metadata":{},"sourceType":"script"}