{"ast":null,"code":"// Presets\nvar presetMap = {\n  'html': {\n    skipScheme: 'html',\n    lineBreakScheme: 'html',\n    whitespace: 'collapse'\n  }\n}; // lineBreak Schemes\n\nvar brPat = /<\\s*br(?:[\\s/]*|\\s[^>]*)>/gi;\nvar lineBreakSchemeMap = {\n  'unix': [/\\n/g, '\\n'],\n  'dos': [/\\r\\n/g, '\\r\\n'],\n  'mac': [/\\r/g, '\\r'],\n  'html': [brPat, '<br>'],\n  'xhtml': [brPat, '<br/>']\n}; // skip Schemes\n\nvar skipSchemeMap = {\n  'ansi-color': /\\x1B\\[[^m]*m/g,\n  'html': /<[^>]*>/g,\n  'bbcode': /\\[[^]]*\\]/g\n};\nvar modeMap = {\n  'soft': 1,\n  'hard': 1\n};\nvar wsMap = {\n  'collapse': 1,\n  'default': 1,\n  'line': 1,\n  'all': 1\n};\nvar rlbMap = {\n  'all': 1,\n  'multi': 1,\n  'none': 1\n};\nvar rlbSMPat = /([sm])(\\d+)/;\nvar escapePat = /[-/\\\\^$*+?.()|[\\]{}]/g;\n\nfunction escapeRegExp(s) {\n  return s.replace(escapePat, '\\\\$&');\n}\n\nvar linewrap = module.exports = function (start, stop, params) {\n  if (typeof start === 'object') {\n    params = start;\n    start = params.start;\n    stop = params.stop;\n  }\n\n  if (typeof stop === 'object') {\n    params = stop;\n    start = start || params.start;\n    stop = undefined;\n  }\n\n  if (!stop) {\n    stop = start;\n    start = 0;\n  }\n\n  if (!params) {\n    params = {};\n  } // Supported options and default values.\n\n\n  var preset,\n      mode = 'soft',\n      whitespace = 'default',\n      tabWidth = 4,\n      skip,\n      skipScheme,\n      lineBreak,\n      lineBreakScheme,\n      respectLineBreaks = 'all',\n      respectNum,\n      preservedLineIndent,\n      wrapLineIndent,\n      wrapLineIndentBase;\n  var skipPat;\n  var lineBreakPat, lineBreakStr;\n  var multiLineBreakPat;\n  var preservedLinePrefix = '';\n  var wrapLineIndentPat,\n      wrapLineInitPrefix = '';\n  var tabRepl;\n  var item, flags;\n  var i; // First process presets, because these settings can be overwritten later.\n\n  preset = params.preset;\n\n  if (preset) {\n    if (!(preset instanceof Array)) {\n      preset = [preset];\n    }\n\n    for (i = 0; i < preset.length; i++) {\n      item = presetMap[preset[i]];\n\n      if (item) {\n        if (item.mode) {\n          mode = item.mode;\n        }\n\n        if (item.whitespace) {\n          whitespace = item.whitespace;\n        }\n\n        if (item.tabWidth !== undefined) {\n          tabWidth = item.tabWidth;\n        }\n\n        if (item.skip) {\n          skip = item.skip;\n        }\n\n        if (item.skipScheme) {\n          skipScheme = item.skipScheme;\n        }\n\n        if (item.lineBreak) {\n          lineBreak = item.lineBreak;\n        }\n\n        if (item.lineBreakScheme) {\n          lineBreakScheme = item.lineBreakScheme;\n        }\n\n        if (item.respectLineBreaks) {\n          respectLineBreaks = item.respectLineBreaks;\n        }\n\n        if (item.preservedLineIndent !== undefined) {\n          preservedLineIndent = item.preservedLineIndent;\n        }\n\n        if (item.wrapLineIndent !== undefined) {\n          wrapLineIndent = item.wrapLineIndent;\n        }\n\n        if (item.wrapLineIndentBase) {\n          wrapLineIndentBase = item.wrapLineIndentBase;\n        }\n      } else {\n        throw new TypeError('preset must be one of \"' + Object.keys(presetMap).join('\", \"') + '\"');\n      }\n    }\n  }\n\n  if (params.mode) {\n    if (modeMap[params.mode]) {\n      mode = params.mode;\n    } else {\n      throw new TypeError('mode must be one of \"' + Object.keys(modeMap).join('\", \"') + '\"');\n    }\n  } // Available options: 'collapse', 'default', 'line', and 'all'\n\n\n  if (params.whitespace) {\n    if (wsMap[params.whitespace]) {\n      whitespace = params.whitespace;\n    } else {\n      throw new TypeError('whitespace must be one of \"' + Object.keys(wsMap).join('\", \"') + '\"');\n    }\n  }\n\n  if (params.tabWidth !== undefined) {\n    if (parseInt(params.tabWidth, 10) >= 0) {\n      tabWidth = parseInt(params.tabWidth, 10);\n    } else {\n      throw new TypeError('tabWidth must be a non-negative integer');\n    }\n  }\n\n  tabRepl = new Array(tabWidth + 1).join(' '); // Available options: 'all', 'multi', 'm\\d+', 's\\d+', 'none'\n\n  if (params.respectLineBreaks) {\n    if (rlbMap[params.respectLineBreaks] || rlbSMPat.test(params.respectLineBreaks)) {\n      respectLineBreaks = params.respectLineBreaks;\n    } else {\n      throw new TypeError('respectLineBreaks must be one of \"' + Object.keys(rlbMap).join('\", \"') + '\", \"m<num>\", \"s<num>\"');\n    }\n  } // After these conversions, now we have 4 options in `respectLineBreaks`:\n  // 'all', 'none', 'm' and 's'.\n  // `respectNum` is applicable iff `respectLineBreaks` is either 'm' or 's'.\n\n\n  if (respectLineBreaks === 'multi') {\n    respectLineBreaks = 'm';\n    respectNum = 2;\n  } else if (!rlbMap[respectLineBreaks]) {\n    var match = rlbSMPat.exec(respectLineBreaks);\n    respectLineBreaks = match[1];\n    respectNum = parseInt(match[2], 10);\n  }\n\n  if (params.preservedLineIndent !== undefined) {\n    if (parseInt(params.preservedLineIndent, 10) >= 0) {\n      preservedLineIndent = parseInt(params.preservedLineIndent, 10);\n    } else {\n      throw new TypeError('preservedLineIndent must be a non-negative integer');\n    }\n  }\n\n  if (preservedLineIndent > 0) {\n    preservedLinePrefix = new Array(preservedLineIndent + 1).join(' ');\n  }\n\n  if (params.wrapLineIndent !== undefined) {\n    if (!isNaN(parseInt(params.wrapLineIndent, 10))) {\n      wrapLineIndent = parseInt(params.wrapLineIndent, 10);\n    } else {\n      throw new TypeError('wrapLineIndent must be an integer');\n    }\n  }\n\n  if (params.wrapLineIndentBase) {\n    wrapLineIndentBase = params.wrapLineIndentBase;\n  }\n\n  if (wrapLineIndentBase) {\n    if (wrapLineIndent === undefined) {\n      throw new TypeError('wrapLineIndent must be specified when wrapLineIndentBase is specified');\n    }\n\n    if (wrapLineIndentBase instanceof RegExp) {\n      wrapLineIndentPat = wrapLineIndentBase;\n    } else if (typeof wrapLineIndentBase === 'string') {\n      wrapLineIndentPat = new RegExp(escapeRegExp(wrapLineIndentBase));\n    } else {\n      throw new TypeError('wrapLineIndentBase must be either a RegExp object or a string');\n    }\n  } else if (wrapLineIndent > 0) {\n    wrapLineInitPrefix = new Array(wrapLineIndent + 1).join(' ');\n  } else if (wrapLineIndent < 0) {\n    throw new TypeError('wrapLineIndent must be non-negative when a base is not specified');\n  } // NOTE: For the two RegExps `skipPat` and `lineBreakPat` that can be specified\n  //       by the user:\n  //       1. We require them to be \"global\", so we have to convert them to global\n  //          if the user specifies a non-global regex.\n  //       2. We cannot call `split()` on them, because they may or may not contain\n  //          capturing parentheses which affect the output of `split()`.\n  // Precedence: Regex = Str > Scheme\n\n\n  if (params.skipScheme) {\n    if (skipSchemeMap[params.skipScheme]) {\n      skipScheme = params.skipScheme;\n    } else {\n      throw new TypeError('skipScheme must be one of \"' + Object.keys(skipSchemeMap).join('\", \"') + '\"');\n    }\n  }\n\n  if (params.skip) {\n    skip = params.skip;\n  }\n\n  if (skip) {\n    if (skip instanceof RegExp) {\n      skipPat = skip;\n\n      if (!skipPat.global) {\n        flags = 'g';\n\n        if (skipPat.ignoreCase) {\n          flags += 'i';\n        }\n\n        if (skipPat.multiline) {\n          flags += 'm';\n        }\n\n        skipPat = new RegExp(skipPat.source, flags);\n      }\n    } else if (typeof skip === 'string') {\n      skipPat = new RegExp(escapeRegExp(skip), 'g');\n    } else {\n      throw new TypeError('skip must be either a RegExp object or a string');\n    }\n  }\n\n  if (!skipPat && skipScheme) {\n    skipPat = skipSchemeMap[skipScheme];\n  } // Precedence:\n  // - for lineBreakPat: Regex > Scheme > Str\n  // - for lineBreakStr: Str > Scheme > Regex\n\n\n  if (params.lineBreakScheme) {\n    if (lineBreakSchemeMap[params.lineBreakScheme]) {\n      lineBreakScheme = params.lineBreakScheme;\n    } else {\n      throw new TypeError('lineBreakScheme must be one of \"' + Object.keys(lineBreakSchemeMap).join('\", \"') + '\"');\n    }\n  }\n\n  if (params.lineBreak) {\n    lineBreak = params.lineBreak;\n  }\n\n  if (lineBreakScheme) {\n    // Supported schemes: 'unix', 'dos', 'mac', 'html', 'xhtml'\n    item = lineBreakSchemeMap[lineBreakScheme];\n\n    if (item) {\n      lineBreakPat = item[0];\n      lineBreakStr = item[1];\n    }\n  }\n\n  if (lineBreak) {\n    if (lineBreak instanceof Array) {\n      if (lineBreak.length === 1) {\n        lineBreak = lineBreak[0];\n      } else if (lineBreak.length >= 2) {\n        if (lineBreak[0] instanceof RegExp) {\n          lineBreakPat = lineBreak[0];\n\n          if (typeof lineBreak[1] === 'string') {\n            lineBreakStr = lineBreak[1];\n          }\n        } else if (lineBreak[1] instanceof RegExp) {\n          lineBreakPat = lineBreak[1];\n\n          if (typeof lineBreak[0] === 'string') {\n            lineBreakStr = lineBreak[0];\n          }\n        } else if (typeof lineBreak[0] === 'string' && typeof lineBreak[1] === 'string') {\n          lineBreakPat = new RegExp(escapeRegExp(lineBreak[0]), 'g');\n          lineBreakStr = lineBreak[1];\n        } else {\n          lineBreak = lineBreak[0];\n        }\n      }\n    }\n\n    if (typeof lineBreak === 'string') {\n      lineBreakStr = lineBreak;\n\n      if (!lineBreakPat) {\n        lineBreakPat = new RegExp(escapeRegExp(lineBreak), 'g');\n      }\n    } else if (lineBreak instanceof RegExp) {\n      lineBreakPat = lineBreak;\n    } else if (!(lineBreak instanceof Array)) {\n      throw new TypeError('lineBreak must be a RegExp object, a string, or an array consisted of a RegExp object and a string');\n    }\n  } // Only assign defaults when `lineBreakPat` is not assigned.\n  // So if `params.lineBreak` is a RegExp, we don't have a value in `lineBreakStr`\n  // yet. We will try to get the value from the input string, and if failed, we\n  // will throw an exception.\n\n\n  if (!lineBreakPat) {\n    lineBreakPat = /\\n/g;\n    lineBreakStr = '\\n';\n  } // Create `multiLineBreakPat` based on `lineBreakPat`, that matches strings\n  // consisted of one or more line breaks and zero or more whitespaces.\n  // Also convert `lineBreakPat` to global if not already so.\n\n\n  flags = 'g';\n\n  if (lineBreakPat.ignoreCase) {\n    flags += 'i';\n  }\n\n  if (lineBreakPat.multiline) {\n    flags += 'm';\n  }\n\n  multiLineBreakPat = new RegExp('\\\\s*(?:' + lineBreakPat.source + ')(?:' + lineBreakPat.source + '|\\\\s)*', flags);\n\n  if (!lineBreakPat.global) {\n    lineBreakPat = new RegExp(lineBreakPat.source, flags);\n  } // Initialize other useful variables.\n\n\n  var re = mode === 'hard' ? /\\b/ : /(\\S+\\s+)/;\n  var prefix = new Array(start + 1).join(' ');\n  var wsStrip = whitespace === 'default' || whitespace === 'collapse',\n      wsCollapse = whitespace === 'collapse',\n      wsLine = whitespace === 'line',\n      wsAll = whitespace === 'all';\n  var tabPat = /\\t/g,\n      collapsePat = /  +/g,\n      pPat = /^\\s+/,\n      tPat = /\\s+$/,\n      nonWsPat = /\\S/,\n      wsPat = /\\s/;\n  var wrapLen = stop - start;\n  return function (text) {\n    text = text.toString().replace(tabPat, tabRepl);\n    var match;\n\n    if (!lineBreakStr) {\n      // Try to get lineBreakStr from `text`\n      lineBreakPat.lastIndex = 0;\n      match = lineBreakPat.exec(text);\n\n      if (match) {\n        lineBreakStr = match[0];\n      } else {\n        throw new TypeError('Line break string for the output not specified');\n      }\n    } // text -> blocks; each bloc -> segments; each segment -> chunks\n\n\n    var blocks,\n        base = 0;\n    var mo, arr, b, res; // Split `text` by line breaks.\n\n    blocks = [];\n    multiLineBreakPat.lastIndex = 0;\n    match = multiLineBreakPat.exec(text);\n\n    while (match) {\n      blocks.push(text.substring(base, match.index));\n\n      if (respectLineBreaks !== 'none') {\n        arr = [];\n        b = 0;\n        lineBreakPat.lastIndex = 0;\n        mo = lineBreakPat.exec(match[0]);\n\n        while (mo) {\n          arr.push(match[0].substring(b, mo.index));\n          b = mo.index + mo[0].length;\n          mo = lineBreakPat.exec(match[0]);\n        }\n\n        arr.push(match[0].substring(b));\n        blocks.push({\n          type: 'break',\n          breaks: arr\n        });\n      } else {\n        // Strip line breaks and insert spaces when necessary.\n        if (wsCollapse) {\n          res = ' ';\n        } else {\n          res = match[0].replace(lineBreakPat, '');\n        }\n\n        blocks.push({\n          type: 'break',\n          remaining: res\n        });\n      }\n\n      base = match.index + match[0].length;\n      match = multiLineBreakPat.exec(text);\n    }\n\n    blocks.push(text.substring(base));\n    var i, j, k;\n    var segments;\n\n    if (skipPat) {\n      segments = [];\n\n      for (i = 0; i < blocks.length; i++) {\n        var bloc = blocks[i];\n\n        if (typeof bloc !== 'string') {\n          // This is an object.\n          segments.push(bloc);\n        } else {\n          base = 0;\n          skipPat.lastIndex = 0;\n          match = skipPat.exec(bloc);\n\n          while (match) {\n            segments.push(bloc.substring(base, match.index));\n            segments.push({\n              type: 'skip',\n              value: match[0]\n            });\n            base = match.index + match[0].length;\n            match = skipPat.exec(bloc);\n          }\n\n          segments.push(bloc.substring(base));\n        }\n      }\n    } else {\n      segments = blocks;\n    }\n\n    var chunks = [];\n\n    for (i = 0; i < segments.length; i++) {\n      var segment = segments[i];\n\n      if (typeof segment !== 'string') {\n        // This is an object.\n        chunks.push(segment);\n      } else {\n        if (wsCollapse) {\n          segment = segment.replace(collapsePat, ' ');\n        }\n\n        var parts = segment.split(re),\n            acc = [];\n\n        for (j = 0; j < parts.length; j++) {\n          var x = parts[j];\n\n          if (mode === 'hard') {\n            for (k = 0; k < x.length; k += wrapLen) {\n              acc.push(x.slice(k, k + wrapLen));\n            }\n          } else {\n            acc.push(x);\n          }\n        }\n\n        chunks = chunks.concat(acc);\n      }\n    }\n\n    var curLine = 0,\n        curLineLength = start + preservedLinePrefix.length,\n        lines = [prefix + preservedLinePrefix],\n        // Holds the \"real length\" (excluding trailing whitespaces) of the\n    // current line if it exceeds `stop`, otherwise 0.\n    // ONLY USED when `wsAll` is true, in `finishOffCurLine()`.\n    bulge = 0,\n        // `cleanLine` is true iff we are at the beginning of an output line. By\n    // \"beginning\" we mean it doesn't contain any non-whitespace char yet.\n    // But its `curLineLength` can be greater than `start`, or even possibly\n    // be greater than `stop`, if `wsStrip` is false.\n    //\n    // Note that a \"clean\" line can still contain skip strings, in addition\n    // to whitespaces.\n    //\n    // This variable is used to allow us strip preceding whitespaces when\n    // `wsStrip` is true, or `wsLine` is true and `preservedLine` is false.\n    cleanLine = true,\n        // `preservedLine` is true iff we are in a preserved input line.\n    //\n    // It's used when `wsLine` is true to (combined with `cleanLine`) decide\n    // whether a whitespace is at the beginning of a preserved input line and\n    // should not be stripped.\n    preservedLine = true,\n        // The current indent prefix for wrapped lines.\n    wrapLinePrefix = wrapLineInitPrefix,\n        remnant; // Always returns '' if `beforeHardBreak` is true.\n    //\n    // Assumption: Each call of this function is always followed by a `lines.push()` call.\n    //\n    // This function can change the status of `cleanLine`, but we don't modify the value of\n    // `cleanLine` in this function. It's fine because `cleanLine` will be set to the correct\n    // value after the `lines.push()` call following this function call. We also don't update\n    // `curLineLength` when pushing a new line and it's safe for the same reason.\n\n    function finishOffCurLine(beforeHardBreak) {\n      var str = lines[curLine],\n          idx,\n          ln,\n          rBase;\n\n      if (!wsAll) {\n        // Strip all trailing whitespaces past `start`.\n        idx = str.length - 1;\n\n        while (idx >= start && str[idx] === ' ') {\n          idx--;\n        }\n\n        while (idx >= start && wsPat.test(str[idx])) {\n          idx--;\n        }\n\n        idx++;\n\n        if (idx !== str.length) {\n          lines[curLine] = str.substring(0, idx);\n        }\n\n        if (preservedLine && cleanLine && wsLine && curLineLength > stop) {\n          // Add the remnants to the next line, just like when `wsAll` is true.\n          rBase = str.length - (curLineLength - stop);\n\n          if (rBase < idx) {\n            // We didn't reach `stop` when stripping due to a bulge.\n            rBase = idx;\n          }\n        }\n      } else {\n        // Strip trailing whitespaces exceeding stop.\n        if (curLineLength > stop) {\n          bulge = bulge || stop;\n          rBase = str.length - (curLineLength - bulge);\n          lines[curLine] = str.substring(0, rBase);\n        }\n\n        bulge = 0;\n      } // Bug: the current implementation of `wrapLineIndent` is buggy: we are not\n      // taking the extra space occupied by the additional indentation into account\n      // when wrapping the line. For example, in \"hard\" mode, we should hard-wrap\n      // long words at `wrapLen - wrapLinePrefix.length` instead of `wrapLen`;\n      // and remnants should also be wrapped at `wrapLen - wrapLinePrefix.length`.\n\n\n      if (preservedLine) {\n        // This is a preserved line, and the next output line isn't a\n        // preserved line.\n        preservedLine = false;\n\n        if (wrapLineIndentPat) {\n          idx = lines[curLine].substring(start).search(wrapLineIndentPat);\n\n          if (idx >= 0 && idx + wrapLineIndent > 0) {\n            wrapLinePrefix = new Array(idx + wrapLineIndent + 1).join(' ');\n          } else {\n            wrapLinePrefix = '';\n          }\n        }\n      } // Some remnants are left to the next line.\n\n\n      if (rBase) {\n        while (rBase + wrapLen < str.length) {\n          if (wsAll) {\n            ln = str.substring(rBase, rBase + wrapLen);\n            lines.push(prefix + wrapLinePrefix + ln);\n          } else {\n            lines.push(prefix + wrapLinePrefix);\n          }\n\n          rBase += wrapLen;\n          curLine++;\n        }\n\n        if (beforeHardBreak) {\n          if (wsAll) {\n            ln = str.substring(rBase);\n            lines.push(prefix + wrapLinePrefix + ln);\n          } else {\n            lines.push(prefix + wrapLinePrefix);\n          }\n\n          curLine++;\n        } else {\n          ln = str.substring(rBase);\n          return wrapLinePrefix + ln;\n        }\n      }\n\n      return '';\n    }\n\n    for (i = 0; i < chunks.length; i++) {\n      var chunk = chunks[i];\n\n      if (chunk === '') {\n        continue;\n      }\n\n      if (typeof chunk !== 'string') {\n        if (chunk.type === 'break') {\n          // This is one or more line breaks.\n          // Each entry in `breaks` is just zero or more whitespaces.\n          if (respectLineBreaks !== 'none') {\n            // Note that if `whitespace` is \"collapse\", we still need\n            // to collapse whitespaces in entries of `breaks`.\n            var breaks = chunk.breaks;\n            var num = breaks.length - 1;\n\n            if (respectLineBreaks === 's') {\n              // This is the most complex scenario. We have to check\n              // the line breaks one by one.\n              for (j = 0; j < num; j++) {\n                if (breaks[j + 1].length < respectNum) {\n                  // This line break should be stripped.\n                  if (wsCollapse) {\n                    breaks[j + 1] = ' ';\n                  } else {\n                    breaks[j + 1] = breaks[j] + breaks[j + 1];\n                  }\n                } else {\n                  // This line break should be preserved.\n                  // First finish off the current line.\n                  if (wsAll) {\n                    lines[curLine] += breaks[j];\n                    curLineLength += breaks[j].length;\n                  }\n\n                  finishOffCurLine(true);\n                  lines.push(prefix + preservedLinePrefix);\n                  curLine++;\n                  curLineLength = start + preservedLinePrefix.length;\n                  preservedLine = cleanLine = true;\n                }\n              } // We are adding to either the existing line (if no line break\n              // is qualified for preservance) or a \"new\" line.\n\n\n              if (!cleanLine || wsAll || wsLine && preservedLine) {\n                if (wsCollapse || !cleanLine && breaks[num] === '') {\n                  breaks[num] = ' ';\n                }\n\n                lines[curLine] += breaks[num];\n                curLineLength += breaks[num].length;\n              }\n            } else if (respectLineBreaks === 'm' && num < respectNum) {\n              // These line breaks should be stripped.\n              if (!cleanLine || wsAll || wsLine && preservedLine) {\n                if (wsCollapse) {\n                  chunk = ' ';\n                } else {\n                  chunk = breaks.join('');\n\n                  if (!cleanLine && chunk === '') {\n                    chunk = ' ';\n                  }\n                }\n\n                lines[curLine] += chunk;\n                curLineLength += chunk.length;\n              }\n            } else {\n              // 'all' || ('m' && num >= respectNum)\n              // These line breaks should be preserved.\n              if (wsStrip) {\n                // Finish off the current line.\n                finishOffCurLine(true);\n\n                for (j = 0; j < num; j++) {\n                  lines.push(prefix + preservedLinePrefix);\n                  curLine++;\n                }\n\n                curLineLength = start + preservedLinePrefix.length;\n                preservedLine = cleanLine = true;\n              } else {\n                if (wsAll || preservedLine && cleanLine) {\n                  lines[curLine] += breaks[0];\n                  curLineLength += breaks[0].length;\n                }\n\n                for (j = 0; j < num; j++) {\n                  // Finish off the current line.\n                  finishOffCurLine(true);\n                  lines.push(prefix + preservedLinePrefix + breaks[j + 1]);\n                  curLine++;\n                  curLineLength = start + preservedLinePrefix.length + breaks[j + 1].length;\n                  preservedLine = cleanLine = true;\n                }\n              }\n            }\n          } else {\n            // These line breaks should be stripped.\n            if (!cleanLine || wsAll || wsLine && preservedLine) {\n              chunk = chunk.remaining; // Bug: If `wsAll` is true, `cleanLine` is false, and `chunk`\n              // is '', we insert a space to replace the line break. This\n              // space will be preserved even if we are at the end of an\n              // output line, which is wrong behavior. However, I'm not\n              // sure it's worth it to fix this edge case.\n\n              if (wsCollapse || !cleanLine && chunk === '') {\n                chunk = ' ';\n              }\n\n              lines[curLine] += chunk;\n              curLineLength += chunk.length;\n            }\n          }\n        } else if (chunk.type === 'skip') {\n          // This is a skip string.\n          // Assumption: skip strings don't end with whitespaces.\n          if (curLineLength > stop) {\n            remnant = finishOffCurLine(false);\n            lines.push(prefix + wrapLinePrefix);\n            curLine++;\n            curLineLength = start + wrapLinePrefix.length;\n\n            if (remnant) {\n              lines[curLine] += remnant;\n              curLineLength += remnant.length;\n            }\n\n            cleanLine = true;\n          }\n\n          lines[curLine] += chunk.value;\n        }\n\n        continue;\n      }\n\n      var chunk2;\n\n      while (1) {\n        chunk2 = undefined;\n\n        if (curLineLength + chunk.length > stop && curLineLength + (chunk2 = chunk.replace(tPat, '')).length > stop && chunk2 !== '' && curLineLength > start) {\n          // This line is full, add `chunk` to the next line\n          remnant = finishOffCurLine(false);\n          lines.push(prefix + wrapLinePrefix);\n          curLine++;\n          curLineLength = start + wrapLinePrefix.length;\n\n          if (remnant) {\n            lines[curLine] += remnant;\n            curLineLength += remnant.length;\n            cleanLine = true;\n            continue;\n          }\n\n          if (wsStrip || wsLine && !(preservedLine && cleanLine)) {\n            chunk = chunk.replace(pPat, '');\n          }\n\n          cleanLine = false;\n        } else {\n          // Add `chunk` to this line\n          if (cleanLine) {\n            if (wsStrip || wsLine && !(preservedLine && cleanLine)) {\n              chunk = chunk.replace(pPat, '');\n\n              if (chunk !== '') {\n                cleanLine = false;\n              }\n            } else {\n              if (nonWsPat.test(chunk)) {\n                cleanLine = false;\n              }\n            }\n          }\n        }\n\n        break;\n      }\n\n      if (wsAll && chunk2 && curLineLength + chunk2.length > stop) {\n        bulge = curLineLength + chunk2.length;\n      }\n\n      lines[curLine] += chunk;\n      curLineLength += chunk.length;\n    } // Finally, finish off the last line.\n\n\n    finishOffCurLine(true);\n    return lines.join(lineBreakStr);\n  };\n};\n\nlinewrap.soft = linewrap;\n\nlinewrap.hard = function () {\n  var args = [].slice.call(arguments);\n  var last = args.length - 1;\n\n  if (typeof args[last] === 'object') {\n    args[last].mode = 'hard';\n  } else {\n    args.push({\n      mode: 'hard'\n    });\n  }\n\n  return linewrap.apply(null, args);\n};\n\nlinewrap.wrap = function (text\n/*, start, stop, params*/\n) {\n  var args = [].slice.call(arguments);\n  args.shift();\n  return linewrap.apply(null, args)(text);\n};","map":{"version":3,"sources":["/Users/sirin/go/src/github.com/sirinibin/reactjs-pos/node_modules/linewrap/index.js"],"names":["presetMap","skipScheme","lineBreakScheme","whitespace","brPat","lineBreakSchemeMap","skipSchemeMap","modeMap","wsMap","rlbMap","rlbSMPat","escapePat","escapeRegExp","s","replace","linewrap","module","exports","start","stop","params","undefined","preset","mode","tabWidth","skip","lineBreak","respectLineBreaks","respectNum","preservedLineIndent","wrapLineIndent","wrapLineIndentBase","skipPat","lineBreakPat","lineBreakStr","multiLineBreakPat","preservedLinePrefix","wrapLineIndentPat","wrapLineInitPrefix","tabRepl","item","flags","i","Array","length","TypeError","Object","keys","join","parseInt","test","match","exec","isNaN","RegExp","global","ignoreCase","multiline","source","re","prefix","wsStrip","wsCollapse","wsLine","wsAll","tabPat","collapsePat","pPat","tPat","nonWsPat","wsPat","wrapLen","text","toString","lastIndex","blocks","base","mo","arr","b","res","push","substring","index","type","breaks","remaining","j","k","segments","bloc","value","chunks","segment","parts","split","acc","x","slice","concat","curLine","curLineLength","lines","bulge","cleanLine","preservedLine","wrapLinePrefix","remnant","finishOffCurLine","beforeHardBreak","str","idx","ln","rBase","search","chunk","num","chunk2","soft","hard","args","call","arguments","last","apply","wrap","shift"],"mappings":"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","sourcesContent":["\n// Presets\nvar presetMap = {\n    'html': {\n        skipScheme: 'html',\n        lineBreakScheme: 'html',\n        whitespace: 'collapse'\n    }\n};\n\n// lineBreak Schemes\nvar brPat = /<\\s*br(?:[\\s/]*|\\s[^>]*)>/gi;\nvar lineBreakSchemeMap = {\n    'unix': [/\\n/g, '\\n'],\n    'dos': [/\\r\\n/g, '\\r\\n'],\n    'mac': [/\\r/g, '\\r'],\n    'html': [brPat, '<br>'],\n    'xhtml': [brPat, '<br/>']\n};\n\n// skip Schemes\nvar skipSchemeMap = {\n    'ansi-color': /\\x1B\\[[^m]*m/g,\n    'html': /<[^>]*>/g,\n    'bbcode': /\\[[^]]*\\]/g\n};\n\nvar modeMap = {\n    'soft': 1,\n    'hard': 1\n};\n\nvar wsMap = {\n    'collapse': 1,\n    'default': 1,\n    'line': 1,\n    'all': 1\n};\n\nvar rlbMap = {\n    'all': 1,\n    'multi': 1,\n    'none': 1\n};\nvar rlbSMPat = /([sm])(\\d+)/;\n\nvar escapePat = /[-/\\\\^$*+?.()|[\\]{}]/g;\nfunction escapeRegExp(s) {\n    return s.replace(escapePat, '\\\\$&');\n}\n\nvar linewrap = module.exports = function (start, stop, params) {\n    if (typeof start === 'object') {\n        params = start;\n        start = params.start;\n        stop = params.stop;\n    }\n\n    if (typeof stop === 'object') {\n        params = stop;\n        start = start || params.start;\n        stop = undefined;\n    }\n\n    if (!stop) {\n        stop = start;\n        start = 0;\n    }\n\n    if (!params) { params = {}; }\n    // Supported options and default values.\n    var preset,\n        mode = 'soft',\n        whitespace = 'default',\n        tabWidth = 4,\n        skip, skipScheme, lineBreak, lineBreakScheme,\n        respectLineBreaks = 'all',\n        respectNum,\n        preservedLineIndent,\n        wrapLineIndent, wrapLineIndentBase;\n\n    var skipPat;\n    var lineBreakPat, lineBreakStr;\n    var multiLineBreakPat;\n    var preservedLinePrefix = '';\n    var wrapLineIndentPat, wrapLineInitPrefix = '';\n    var tabRepl;\n    var item, flags;\n    var i;\n\n    // First process presets, because these settings can be overwritten later.\n    preset = params.preset;\n    if (preset) {\n        if (!(preset instanceof Array)) {\n            preset = [preset];\n        }\n        for (i = 0; i < preset.length; i++) {\n            item = presetMap[preset[i]];\n            if (item) {\n                if (item.mode) {\n                    mode = item.mode;\n                }\n                if (item.whitespace) {\n                    whitespace = item.whitespace;\n                }\n                if (item.tabWidth !== undefined) {\n                    tabWidth = item.tabWidth;\n                }\n                if (item.skip) {\n                    skip = item.skip;\n                }\n                if (item.skipScheme) {\n                    skipScheme = item.skipScheme;\n                }\n                if (item.lineBreak) {\n                    lineBreak = item.lineBreak;\n                }\n                if (item.lineBreakScheme) {\n                    lineBreakScheme = item.lineBreakScheme;\n                }\n                if (item.respectLineBreaks) {\n                    respectLineBreaks = item.respectLineBreaks;\n                }\n                if (item.preservedLineIndent !== undefined) {\n                    preservedLineIndent = item.preservedLineIndent;\n                }\n                if (item.wrapLineIndent !== undefined) {\n                    wrapLineIndent = item.wrapLineIndent;\n                }\n                if (item.wrapLineIndentBase) {\n                    wrapLineIndentBase = item.wrapLineIndentBase;\n                }\n            } else {\n                throw new TypeError('preset must be one of \"' + Object.keys(presetMap).join('\", \"') + '\"');\n            }\n        }\n    }\n\n    if (params.mode) {\n        if (modeMap[params.mode]) {\n            mode = params.mode;\n        } else {\n            throw new TypeError('mode must be one of \"' + Object.keys(modeMap).join('\", \"') + '\"');\n        }\n    }\n    // Available options: 'collapse', 'default', 'line', and 'all'\n    if (params.whitespace) {\n        if (wsMap[params.whitespace]) {\n            whitespace = params.whitespace;\n        } else {\n            throw new TypeError('whitespace must be one of \"' + Object.keys(wsMap).join('\", \"') + '\"');\n        }\n    }\n\n    if (params.tabWidth !== undefined) {\n        if (parseInt(params.tabWidth, 10) >= 0) {\n            tabWidth = parseInt(params.tabWidth, 10);\n        } else {\n            throw new TypeError('tabWidth must be a non-negative integer');\n        }\n    }\n    tabRepl = new Array(tabWidth + 1).join(' ');\n\n    // Available options: 'all', 'multi', 'm\\d+', 's\\d+', 'none'\n    if (params.respectLineBreaks) {\n        if (rlbMap[params.respectLineBreaks] || rlbSMPat.test(params.respectLineBreaks)) {\n            respectLineBreaks = params.respectLineBreaks;\n        } else {\n            throw new TypeError('respectLineBreaks must be one of \"' + Object.keys(rlbMap).join('\", \"') +\n                                '\", \"m<num>\", \"s<num>\"');\n        }\n    }\n    // After these conversions, now we have 4 options in `respectLineBreaks`:\n    // 'all', 'none', 'm' and 's'.\n    // `respectNum` is applicable iff `respectLineBreaks` is either 'm' or 's'.\n    if (respectLineBreaks === 'multi') {\n        respectLineBreaks = 'm';\n        respectNum = 2;\n    } else if (!rlbMap[respectLineBreaks]) {\n        var match = rlbSMPat.exec(respectLineBreaks);\n        respectLineBreaks = match[1];\n        respectNum = parseInt(match[2], 10);\n    }\n\n    if (params.preservedLineIndent !== undefined) {\n        if (parseInt(params.preservedLineIndent, 10) >= 0) {\n            preservedLineIndent = parseInt(params.preservedLineIndent, 10);\n        } else {\n            throw new TypeError('preservedLineIndent must be a non-negative integer');\n        }\n    }\n\n    if (preservedLineIndent > 0) {\n        preservedLinePrefix = new Array(preservedLineIndent + 1).join(' ');\n    }\n\n    if (params.wrapLineIndent !== undefined) {\n        if (!isNaN(parseInt(params.wrapLineIndent, 10))) {\n            wrapLineIndent = parseInt(params.wrapLineIndent, 10);\n        } else {\n            throw new TypeError('wrapLineIndent must be an integer');\n        }\n    }\n    if (params.wrapLineIndentBase) {\n        wrapLineIndentBase = params.wrapLineIndentBase;\n    }\n\n    if (wrapLineIndentBase) {\n        if (wrapLineIndent === undefined) {\n            throw new TypeError('wrapLineIndent must be specified when wrapLineIndentBase is specified');\n        }\n        if (wrapLineIndentBase instanceof RegExp) {\n            wrapLineIndentPat = wrapLineIndentBase;\n        } else if (typeof wrapLineIndentBase === 'string') {\n            wrapLineIndentPat = new RegExp(escapeRegExp(wrapLineIndentBase));\n        } else {\n            throw new TypeError('wrapLineIndentBase must be either a RegExp object or a string');\n        }\n    } else if (wrapLineIndent > 0) {\n        wrapLineInitPrefix = new Array(wrapLineIndent + 1).join(' ');\n    } else if (wrapLineIndent < 0) {\n        throw new TypeError('wrapLineIndent must be non-negative when a base is not specified');\n    }\n\n    // NOTE: For the two RegExps `skipPat` and `lineBreakPat` that can be specified\n    //       by the user:\n    //       1. We require them to be \"global\", so we have to convert them to global\n    //          if the user specifies a non-global regex.\n    //       2. We cannot call `split()` on them, because they may or may not contain\n    //          capturing parentheses which affect the output of `split()`.\n\n    // Precedence: Regex = Str > Scheme\n    if (params.skipScheme) {\n        if (skipSchemeMap[params.skipScheme]) {\n            skipScheme = params.skipScheme;\n        } else {\n            throw new TypeError('skipScheme must be one of \"' + Object.keys(skipSchemeMap).join('\", \"') + '\"');\n        }\n    }\n    if (params.skip) {\n        skip = params.skip;\n    }\n\n    if (skip) {\n        if (skip instanceof RegExp) {\n            skipPat = skip;\n            if (!skipPat.global) {\n                flags = 'g';\n                if (skipPat.ignoreCase) { flags += 'i'; }\n                if (skipPat.multiline) { flags += 'm'; }\n                skipPat = new RegExp(skipPat.source, flags);\n            }\n        } else if (typeof skip === 'string') {\n            skipPat = new RegExp(escapeRegExp(skip), 'g');\n        } else {\n            throw new TypeError('skip must be either a RegExp object or a string');\n        }\n    }\n    if (!skipPat && skipScheme) {\n        skipPat = skipSchemeMap[skipScheme];\n    }\n\n    // Precedence:\n    // - for lineBreakPat: Regex > Scheme > Str\n    // - for lineBreakStr: Str > Scheme > Regex\n    if (params.lineBreakScheme) {\n        if (lineBreakSchemeMap[params.lineBreakScheme]) {\n            lineBreakScheme = params.lineBreakScheme;\n        } else {\n            throw new TypeError('lineBreakScheme must be one of \"' + Object.keys(lineBreakSchemeMap).join('\", \"') + '\"');\n        }\n    }\n    if (params.lineBreak) {\n        lineBreak = params.lineBreak;\n    }\n\n    if (lineBreakScheme) {\n        // Supported schemes: 'unix', 'dos', 'mac', 'html', 'xhtml'\n        item = lineBreakSchemeMap[lineBreakScheme];\n        if (item) {\n            lineBreakPat = item[0];\n            lineBreakStr = item[1];\n        }\n    }\n    if (lineBreak) {\n        if (lineBreak instanceof Array) {\n            if (lineBreak.length === 1) {\n                lineBreak = lineBreak[0];\n            } else if (lineBreak.length >= 2) {\n                if (lineBreak[0] instanceof RegExp) {\n                    lineBreakPat = lineBreak[0];\n                    if (typeof lineBreak[1] === 'string') {\n                        lineBreakStr = lineBreak[1];\n                    }\n                } else if (lineBreak[1] instanceof RegExp) {\n                    lineBreakPat = lineBreak[1];\n                    if (typeof lineBreak[0] === 'string') {\n                        lineBreakStr = lineBreak[0];\n                    }\n                } else if (typeof lineBreak[0] === 'string' && typeof lineBreak[1] === 'string') {\n                    lineBreakPat = new RegExp(escapeRegExp(lineBreak[0]), 'g');\n                    lineBreakStr = lineBreak[1];\n                } else {\n                    lineBreak = lineBreak[0];\n                }\n            }\n        }\n        if (typeof lineBreak === 'string') {\n            lineBreakStr = lineBreak;\n            if (!lineBreakPat) {\n                lineBreakPat = new RegExp(escapeRegExp(lineBreak), 'g');\n            }\n        } else if (lineBreak instanceof RegExp) {\n            lineBreakPat = lineBreak;\n        } else if (!(lineBreak instanceof Array)) {\n            throw new TypeError('lineBreak must be a RegExp object, a string, or an array consisted of a RegExp object and a string');\n        }\n    }\n    // Only assign defaults when `lineBreakPat` is not assigned.\n    // So if `params.lineBreak` is a RegExp, we don't have a value in `lineBreakStr`\n    // yet. We will try to get the value from the input string, and if failed, we\n    // will throw an exception.\n    if (!lineBreakPat) {\n        lineBreakPat = /\\n/g;\n        lineBreakStr = '\\n';\n    }\n\n    // Create `multiLineBreakPat` based on `lineBreakPat`, that matches strings\n    // consisted of one or more line breaks and zero or more whitespaces.\n    // Also convert `lineBreakPat` to global if not already so.\n    flags = 'g';\n    if (lineBreakPat.ignoreCase) { flags += 'i'; }\n    if (lineBreakPat.multiline) { flags += 'm'; }\n    multiLineBreakPat = new RegExp('\\\\s*(?:' + lineBreakPat.source + ')(?:' +\n                                   lineBreakPat.source + '|\\\\s)*', flags);\n    if (!lineBreakPat.global) {\n        lineBreakPat = new RegExp(lineBreakPat.source, flags);\n    }\n\n    // Initialize other useful variables.\n    var re = mode === 'hard' ? /\\b/ : /(\\S+\\s+)/;\n    var prefix = new Array(start + 1).join(' ');\n    var wsStrip = (whitespace === 'default' || whitespace === 'collapse'),\n        wsCollapse = (whitespace === 'collapse'),\n        wsLine = (whitespace === 'line'),\n        wsAll = (whitespace === 'all');\n    var tabPat = /\\t/g,\n        collapsePat = /  +/g,\n        pPat = /^\\s+/,\n        tPat = /\\s+$/,\n        nonWsPat = /\\S/,\n        wsPat = /\\s/;\n    var wrapLen = stop - start;\n\n    return function (text) {\n        text = text.toString().replace(tabPat, tabRepl);\n\n        var match;\n        if (!lineBreakStr) {\n            // Try to get lineBreakStr from `text`\n            lineBreakPat.lastIndex = 0;\n            match = lineBreakPat.exec(text);\n            if (match) {\n                lineBreakStr = match[0];\n            } else {\n                throw new TypeError('Line break string for the output not specified');\n            }\n        }\n\n        // text -> blocks; each bloc -> segments; each segment -> chunks\n        var blocks, base = 0;\n        var mo, arr, b, res;\n        // Split `text` by line breaks.\n        blocks = [];\n        multiLineBreakPat.lastIndex = 0;\n        match = multiLineBreakPat.exec(text);\n        while(match) {\n            blocks.push(text.substring(base, match.index));\n\n            if (respectLineBreaks !== 'none') {\n                arr = [];\n                b = 0;\n                lineBreakPat.lastIndex = 0;\n                mo = lineBreakPat.exec(match[0]);\n                while(mo) {\n                    arr.push(match[0].substring(b, mo.index));\n                    b = mo.index + mo[0].length;\n                    mo = lineBreakPat.exec(match[0]);\n                }\n                arr.push(match[0].substring(b));\n                blocks.push({type: 'break', breaks: arr});\n            } else {\n                // Strip line breaks and insert spaces when necessary.\n                if (wsCollapse) {\n                    res = ' ';\n                } else {\n                    res = match[0].replace(lineBreakPat, '');\n                }\n                blocks.push({type: 'break', remaining: res});\n            }\n\n            base = match.index + match[0].length;\n            match = multiLineBreakPat.exec(text);\n        }\n        blocks.push(text.substring(base));\n\n        var i, j, k;\n        var segments;\n        if (skipPat) {\n            segments = [];\n            for (i = 0; i < blocks.length; i++) {\n                var bloc = blocks[i];\n                if (typeof bloc !== 'string') {\n                    // This is an object.\n                    segments.push(bloc);\n                } else {\n                    base = 0;\n                    skipPat.lastIndex = 0;\n                    match = skipPat.exec(bloc);\n                    while(match) {\n                        segments.push(bloc.substring(base, match.index));\n                        segments.push({type: 'skip', value: match[0]});\n                        base = match.index + match[0].length;\n                        match = skipPat.exec(bloc);\n                    }\n                    segments.push(bloc.substring(base));\n                }\n            }\n        } else {\n            segments = blocks;\n        }\n\n        var chunks = [];\n        for (i = 0; i < segments.length; i++) {\n            var segment = segments[i];\n            if (typeof segment !== 'string') {\n                // This is an object.\n                chunks.push(segment);\n            } else {\n                if (wsCollapse) {\n                    segment = segment.replace(collapsePat, ' ');\n                }\n\n                var parts = segment.split(re),\n                    acc = [];\n\n                for (j = 0; j < parts.length; j++) {\n                    var x = parts[j];\n                    if (mode === 'hard') {\n                        for (k = 0; k < x.length; k += wrapLen) {\n                            acc.push(x.slice(k, k + wrapLen));\n                        }\n                    }\n                    else { acc.push(x); }\n                }\n                chunks = chunks.concat(acc);\n            }\n        }\n\n        var curLine = 0,\n            curLineLength = start + preservedLinePrefix.length,\n            lines = [ prefix + preservedLinePrefix ],\n            // Holds the \"real length\" (excluding trailing whitespaces) of the\n            // current line if it exceeds `stop`, otherwise 0.\n            // ONLY USED when `wsAll` is true, in `finishOffCurLine()`.\n            bulge = 0,\n            // `cleanLine` is true iff we are at the beginning of an output line. By\n            // \"beginning\" we mean it doesn't contain any non-whitespace char yet.\n            // But its `curLineLength` can be greater than `start`, or even possibly\n            // be greater than `stop`, if `wsStrip` is false.\n            //\n            // Note that a \"clean\" line can still contain skip strings, in addition\n            // to whitespaces.\n            //\n            // This variable is used to allow us strip preceding whitespaces when\n            // `wsStrip` is true, or `wsLine` is true and `preservedLine` is false.\n            cleanLine = true,\n            // `preservedLine` is true iff we are in a preserved input line.\n            //\n            // It's used when `wsLine` is true to (combined with `cleanLine`) decide\n            // whether a whitespace is at the beginning of a preserved input line and\n            // should not be stripped.\n            preservedLine = true,\n            // The current indent prefix for wrapped lines.\n            wrapLinePrefix = wrapLineInitPrefix,\n            remnant;\n\n        // Always returns '' if `beforeHardBreak` is true.\n        //\n        // Assumption: Each call of this function is always followed by a `lines.push()` call.\n        //\n        // This function can change the status of `cleanLine`, but we don't modify the value of\n        // `cleanLine` in this function. It's fine because `cleanLine` will be set to the correct\n        // value after the `lines.push()` call following this function call. We also don't update\n        // `curLineLength` when pushing a new line and it's safe for the same reason.\n        function finishOffCurLine(beforeHardBreak) {\n            var str = lines[curLine],\n                idx, ln, rBase;\n\n            if (!wsAll) {\n                // Strip all trailing whitespaces past `start`.\n                idx = str.length - 1;\n                while (idx >= start && str[idx] === ' ') { idx--; }\n                while (idx >= start && wsPat.test(str[idx])) { idx--; }\n                idx++;\n\n                if (idx !== str.length) {\n                    lines[curLine] = str.substring(0, idx);\n                }\n\n                if (preservedLine && cleanLine && wsLine && curLineLength > stop) {\n                    // Add the remnants to the next line, just like when `wsAll` is true.\n                    rBase = str.length - (curLineLength - stop);\n                    if (rBase < idx) {\n                        // We didn't reach `stop` when stripping due to a bulge.\n                        rBase = idx;\n                    }\n                }\n            } else {\n                // Strip trailing whitespaces exceeding stop.\n                if (curLineLength > stop) {\n                    bulge = bulge || stop;\n                    rBase = str.length - (curLineLength - bulge);\n                    lines[curLine] = str.substring(0,  rBase);\n                }\n                bulge = 0;\n            }\n\n            // Bug: the current implementation of `wrapLineIndent` is buggy: we are not\n            // taking the extra space occupied by the additional indentation into account\n            // when wrapping the line. For example, in \"hard\" mode, we should hard-wrap\n            // long words at `wrapLen - wrapLinePrefix.length` instead of `wrapLen`;\n            // and remnants should also be wrapped at `wrapLen - wrapLinePrefix.length`.\n            if (preservedLine) {\n                // This is a preserved line, and the next output line isn't a\n                // preserved line.\n                preservedLine = false;\n                if (wrapLineIndentPat) {\n                    idx = lines[curLine].substring(start).search(wrapLineIndentPat);\n                    if (idx >= 0 && idx + wrapLineIndent > 0) {\n                        wrapLinePrefix = new Array(idx + wrapLineIndent + 1).join(' ');\n                    } else {\n                        wrapLinePrefix = '';\n                    }\n                }\n            }\n\n            // Some remnants are left to the next line.\n            if (rBase) {\n                while (rBase + wrapLen < str.length) {\n                    if (wsAll) {\n                        ln = str.substring(rBase, rBase + wrapLen);\n                        lines.push(prefix + wrapLinePrefix + ln);\n                    } else {\n                        lines.push(prefix + wrapLinePrefix);\n                    }\n                    rBase += wrapLen;\n                    curLine++;\n                }\n                if (beforeHardBreak) {\n                    if (wsAll) {\n                        ln = str.substring(rBase);\n                        lines.push(prefix + wrapLinePrefix + ln);\n                    } else {\n                        lines.push(prefix + wrapLinePrefix);\n                    }\n                    curLine++;\n                } else {\n                    ln = str.substring(rBase);\n                    return wrapLinePrefix + ln;\n                }\n            }\n\n            return '';\n        }\n\n        for (i = 0; i < chunks.length; i++) {\n            var chunk = chunks[i];\n\n            if (chunk === '') { continue; }\n\n            if (typeof chunk !== 'string') {\n                if (chunk.type === 'break') {\n                    // This is one or more line breaks.\n                    // Each entry in `breaks` is just zero or more whitespaces.\n                    if (respectLineBreaks !== 'none') {\n                        // Note that if `whitespace` is \"collapse\", we still need\n                        // to collapse whitespaces in entries of `breaks`.\n                        var breaks = chunk.breaks;\n                        var num = breaks.length - 1;\n\n                        if (respectLineBreaks === 's') {\n                            // This is the most complex scenario. We have to check\n                            // the line breaks one by one.\n                            for (j = 0; j < num; j++) {\n                                if (breaks[j+1].length < respectNum) {\n                                    // This line break should be stripped.\n                                    if (wsCollapse) {\n                                        breaks[j+1] = ' ';\n                                    } else {\n                                        breaks[j+1] = breaks[j] + breaks[j+1];\n                                    }\n                                } else {\n                                    // This line break should be preserved.\n                                    // First finish off the current line.\n                                    if (wsAll) {\n                                        lines[curLine] += breaks[j];\n                                        curLineLength += breaks[j].length;\n                                    }\n                                    finishOffCurLine(true);\n\n                                    lines.push(prefix + preservedLinePrefix);\n                                    curLine++;\n                                    curLineLength = start + preservedLinePrefix.length;\n\n                                    preservedLine = cleanLine = true;\n                                }\n                            }\n                            // We are adding to either the existing line (if no line break\n                            // is qualified for preservance) or a \"new\" line.\n                            if (!cleanLine || wsAll || (wsLine && preservedLine)) {\n                                if (wsCollapse || (!cleanLine && breaks[num] === '')) {\n                                    breaks[num] = ' ';\n                                }\n                                lines[curLine] += breaks[num];\n                                curLineLength += breaks[num].length;\n                            }\n                        } else if (respectLineBreaks === 'm' && num < respectNum) {\n                            // These line breaks should be stripped.\n                            if (!cleanLine || wsAll || (wsLine && preservedLine)) {\n                                if (wsCollapse) {\n                                    chunk = ' ';\n                                } else {\n                                    chunk = breaks.join('');\n                                    if (!cleanLine && chunk === '') {\n                                        chunk = ' ';\n                                    }\n                                }\n                                lines[curLine] += chunk;\n                                curLineLength += chunk.length;\n                            }\n                        } else {    // 'all' || ('m' && num >= respectNum)\n                            // These line breaks should be preserved.\n                            if (wsStrip) {\n                                // Finish off the current line.\n                                finishOffCurLine(true);\n\n                                for (j = 0; j < num; j++) {\n                                    lines.push(prefix + preservedLinePrefix);\n                                    curLine++;\n                                }\n\n                                curLineLength = start + preservedLinePrefix.length;\n                                preservedLine = cleanLine = true;\n\n                            } else {\n                                if (wsAll || (preservedLine && cleanLine)) {\n                                    lines[curLine] += breaks[0];\n                                    curLineLength += breaks[0].length;\n                                }\n\n                                for (j = 0; j < num; j++) {\n                                    // Finish off the current line.\n                                    finishOffCurLine(true);\n\n                                    lines.push(prefix + preservedLinePrefix + breaks[j+1]);\n                                    curLine++;\n                                    curLineLength = start + preservedLinePrefix.length + breaks[j+1].length;\n\n                                    preservedLine = cleanLine = true;\n                                }\n                            }\n                        }\n                    } else {\n                        // These line breaks should be stripped.\n                        if (!cleanLine || wsAll || (wsLine && preservedLine)) {\n                            chunk = chunk.remaining;\n\n                            // Bug: If `wsAll` is true, `cleanLine` is false, and `chunk`\n                            // is '', we insert a space to replace the line break. This\n                            // space will be preserved even if we are at the end of an\n                            // output line, which is wrong behavior. However, I'm not\n                            // sure it's worth it to fix this edge case.\n                            if (wsCollapse || (!cleanLine && chunk === '')) {\n                                chunk = ' ';\n                            }\n                            lines[curLine] += chunk;\n                            curLineLength += chunk.length;\n                        }\n                    }\n                } else if (chunk.type === 'skip') {\n                    // This is a skip string.\n                    // Assumption: skip strings don't end with whitespaces.\n                    if (curLineLength > stop) {\n                        remnant = finishOffCurLine(false);\n\n                        lines.push(prefix + wrapLinePrefix);\n                        curLine++;\n                        curLineLength = start + wrapLinePrefix.length;\n\n                        if (remnant) {\n                            lines[curLine] += remnant;\n                            curLineLength += remnant.length;\n                        }\n\n                        cleanLine = true;\n                    }\n                    lines[curLine] += chunk.value;\n                }\n                continue;\n            }\n\n            var chunk2;\n            while (1) {\n                chunk2 = undefined;\n                if (curLineLength + chunk.length > stop &&\n                        curLineLength + (chunk2 = chunk.replace(tPat, '')).length > stop &&\n                        chunk2 !== '' &&\n                        curLineLength > start) {\n                    // This line is full, add `chunk` to the next line\n                    remnant = finishOffCurLine(false);\n\n                    lines.push(prefix + wrapLinePrefix);\n                    curLine++;\n                    curLineLength = start + wrapLinePrefix.length;\n\n                    if (remnant) {\n                        lines[curLine] += remnant;\n                        curLineLength += remnant.length;\n                        cleanLine = true;\n                        continue;\n                    }\n\n                    if (wsStrip || (wsLine && !(preservedLine && cleanLine))) {\n                        chunk = chunk.replace(pPat, '');\n                    }\n                    cleanLine = false;\n\n                } else {\n                    // Add `chunk` to this line\n                    if (cleanLine) {\n                        if (wsStrip || (wsLine && !(preservedLine && cleanLine))) {\n                            chunk = chunk.replace(pPat, '');\n                            if (chunk !== '') {\n                                cleanLine = false;\n                            }\n                        } else {\n                            if (nonWsPat.test(chunk)) {\n                                cleanLine = false;\n                            }\n                        }\n                    }\n                }\n                break;\n            }\n            if (wsAll && chunk2 && curLineLength + chunk2.length > stop) {\n                bulge = curLineLength + chunk2.length;\n            }\n            lines[curLine] += chunk;\n            curLineLength += chunk.length;\n        }\n        // Finally, finish off the last line.\n        finishOffCurLine(true);\n        return lines.join(lineBreakStr);\n    };\n};\n\nlinewrap.soft = linewrap;\n\nlinewrap.hard = function (/*start, stop, params*/) {\n    var args = [].slice.call(arguments);\n    var last = args.length - 1;\n    if (typeof args[last] === 'object') {\n        args[last].mode = 'hard';\n    } else {\n        args.push({ mode : 'hard' });\n    }\n    return linewrap.apply(null, args);\n};\n\nlinewrap.wrap = function(text/*, start, stop, params*/) {\n    var args = [].slice.call(arguments);\n    args.shift();\n    return linewrap.apply(null, args)(text);\n};\n"]},"metadata":{},"sourceType":"script"}