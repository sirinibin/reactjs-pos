{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getTotalWidthOfEncodings = exports.calculateEncodingAttributes = exports.getBarcodePadding = exports.getEncodingHeight = exports.getMaximumHeightOfEncodings = undefined;\n\nvar _merge = require(\"../help/merge.js\");\n\nvar _merge2 = _interopRequireDefault(_merge);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction getEncodingHeight(encoding, options) {\n  return options.height + (options.displayValue && encoding.text.length > 0 ? options.fontSize + options.textMargin : 0) + options.marginTop + options.marginBottom;\n}\n\nfunction getBarcodePadding(textWidth, barcodeWidth, options) {\n  if (options.displayValue && barcodeWidth < textWidth) {\n    if (options.textAlign == \"center\") {\n      return Math.floor((textWidth - barcodeWidth) / 2);\n    } else if (options.textAlign == \"left\") {\n      return 0;\n    } else if (options.textAlign == \"right\") {\n      return Math.floor(textWidth - barcodeWidth);\n    }\n  }\n\n  return 0;\n}\n\nfunction calculateEncodingAttributes(encodings, barcodeOptions, context) {\n  for (var i = 0; i < encodings.length; i++) {\n    var encoding = encodings[i];\n    var options = (0, _merge2.default)(barcodeOptions, encoding.options); // Calculate the width of the encoding\n\n    var textWidth;\n\n    if (options.displayValue) {\n      textWidth = messureText(encoding.text, options, context);\n    } else {\n      textWidth = 0;\n    }\n\n    var barcodeWidth = encoding.data.length * options.width;\n    encoding.width = Math.ceil(Math.max(textWidth, barcodeWidth));\n    encoding.height = getEncodingHeight(encoding, options);\n    encoding.barcodePadding = getBarcodePadding(textWidth, barcodeWidth, options);\n  }\n}\n\nfunction getTotalWidthOfEncodings(encodings) {\n  var totalWidth = 0;\n\n  for (var i = 0; i < encodings.length; i++) {\n    totalWidth += encodings[i].width;\n  }\n\n  return totalWidth;\n}\n\nfunction getMaximumHeightOfEncodings(encodings) {\n  var maxHeight = 0;\n\n  for (var i = 0; i < encodings.length; i++) {\n    if (encodings[i].height > maxHeight) {\n      maxHeight = encodings[i].height;\n    }\n  }\n\n  return maxHeight;\n}\n\nfunction messureText(string, options, context) {\n  var ctx;\n\n  if (context) {\n    ctx = context;\n  } else if (typeof document !== \"undefined\") {\n    ctx = document.createElement(\"canvas\").getContext(\"2d\");\n  } else {\n    // If the text cannot be messured we will return 0.\n    // This will make some barcode with big text render incorrectly\n    return 0;\n  }\n\n  ctx.font = options.fontOptions + \" \" + options.fontSize + \"px \" + options.font; // Calculate the width of the encoding\n\n  var measureTextResult = ctx.measureText(string);\n\n  if (!measureTextResult) {\n    // Some implementations don't implement measureText and return undefined.\n    // If the text cannot be measured we will return 0.\n    // This will make some barcode with big text render incorrectly\n    return 0;\n  }\n\n  var size = measureTextResult.width;\n  return size;\n}\n\nexports.getMaximumHeightOfEncodings = getMaximumHeightOfEncodings;\nexports.getEncodingHeight = getEncodingHeight;\nexports.getBarcodePadding = getBarcodePadding;\nexports.calculateEncodingAttributes = calculateEncodingAttributes;\nexports.getTotalWidthOfEncodings = getTotalWidthOfEncodings;","map":{"version":3,"sources":["/Users/sirin/go/src/github.com/sirinibin/reactjs-pos/node_modules/jsbarcode/bin/renderers/shared.js"],"names":["Object","defineProperty","exports","value","getTotalWidthOfEncodings","calculateEncodingAttributes","getBarcodePadding","getEncodingHeight","getMaximumHeightOfEncodings","undefined","_merge","require","_merge2","_interopRequireDefault","obj","__esModule","default","encoding","options","height","displayValue","text","length","fontSize","textMargin","marginTop","marginBottom","textWidth","barcodeWidth","textAlign","Math","floor","encodings","barcodeOptions","context","i","messureText","data","width","ceil","max","barcodePadding","totalWidth","maxHeight","string","ctx","document","createElement","getContext","font","fontOptions","measureTextResult","measureText","size"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAC5CC,EAAAA,KAAK,EAAE;AADqC,CAA7C;AAGAD,OAAO,CAACE,wBAAR,GAAmCF,OAAO,CAACG,2BAAR,GAAsCH,OAAO,CAACI,iBAAR,GAA4BJ,OAAO,CAACK,iBAAR,GAA4BL,OAAO,CAACM,2BAAR,GAAsCC,SAAvK;;AAEA,IAAIC,MAAM,GAAGC,OAAO,CAAC,kBAAD,CAApB;;AAEA,IAAIC,OAAO,GAAGC,sBAAsB,CAACH,MAAD,CAApC;;AAEA,SAASG,sBAAT,CAAgCC,GAAhC,EAAqC;AAAE,SAAOA,GAAG,IAAIA,GAAG,CAACC,UAAX,GAAwBD,GAAxB,GAA8B;AAAEE,IAAAA,OAAO,EAAEF;AAAX,GAArC;AAAwD;;AAE/F,SAASP,iBAAT,CAA2BU,QAA3B,EAAqCC,OAArC,EAA8C;AAC7C,SAAOA,OAAO,CAACC,MAAR,IAAkBD,OAAO,CAACE,YAAR,IAAwBH,QAAQ,CAACI,IAAT,CAAcC,MAAd,GAAuB,CAA/C,GAAmDJ,OAAO,CAACK,QAAR,GAAmBL,OAAO,CAACM,UAA9E,GAA2F,CAA7G,IAAkHN,OAAO,CAACO,SAA1H,GAAsIP,OAAO,CAACQ,YAArJ;AACA;;AAED,SAASpB,iBAAT,CAA2BqB,SAA3B,EAAsCC,YAAtC,EAAoDV,OAApD,EAA6D;AAC5D,MAAIA,OAAO,CAACE,YAAR,IAAwBQ,YAAY,GAAGD,SAA3C,EAAsD;AACrD,QAAIT,OAAO,CAACW,SAAR,IAAqB,QAAzB,EAAmC;AAClC,aAAOC,IAAI,CAACC,KAAL,CAAW,CAACJ,SAAS,GAAGC,YAAb,IAA6B,CAAxC,CAAP;AACA,KAFD,MAEO,IAAIV,OAAO,CAACW,SAAR,IAAqB,MAAzB,EAAiC;AACvC,aAAO,CAAP;AACA,KAFM,MAEA,IAAIX,OAAO,CAACW,SAAR,IAAqB,OAAzB,EAAkC;AACxC,aAAOC,IAAI,CAACC,KAAL,CAAWJ,SAAS,GAAGC,YAAvB,CAAP;AACA;AACD;;AACD,SAAO,CAAP;AACA;;AAED,SAASvB,2BAAT,CAAqC2B,SAArC,EAAgDC,cAAhD,EAAgEC,OAAhE,EAAyE;AACxE,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,SAAS,CAACV,MAA9B,EAAsCa,CAAC,EAAvC,EAA2C;AAC1C,QAAIlB,QAAQ,GAAGe,SAAS,CAACG,CAAD,CAAxB;AACA,QAAIjB,OAAO,GAAG,CAAC,GAAGN,OAAO,CAACI,OAAZ,EAAqBiB,cAArB,EAAqChB,QAAQ,CAACC,OAA9C,CAAd,CAF0C,CAI1C;;AACA,QAAIS,SAAJ;;AACA,QAAIT,OAAO,CAACE,YAAZ,EAA0B;AACzBO,MAAAA,SAAS,GAAGS,WAAW,CAACnB,QAAQ,CAACI,IAAV,EAAgBH,OAAhB,EAAyBgB,OAAzB,CAAvB;AACA,KAFD,MAEO;AACNP,MAAAA,SAAS,GAAG,CAAZ;AACA;;AAED,QAAIC,YAAY,GAAGX,QAAQ,CAACoB,IAAT,CAAcf,MAAd,GAAuBJ,OAAO,CAACoB,KAAlD;AACArB,IAAAA,QAAQ,CAACqB,KAAT,GAAiBR,IAAI,CAACS,IAAL,CAAUT,IAAI,CAACU,GAAL,CAASb,SAAT,EAAoBC,YAApB,CAAV,CAAjB;AAEAX,IAAAA,QAAQ,CAACE,MAAT,GAAkBZ,iBAAiB,CAACU,QAAD,EAAWC,OAAX,CAAnC;AAEAD,IAAAA,QAAQ,CAACwB,cAAT,GAA0BnC,iBAAiB,CAACqB,SAAD,EAAYC,YAAZ,EAA0BV,OAA1B,CAA3C;AACA;AACD;;AAED,SAASd,wBAAT,CAAkC4B,SAAlC,EAA6C;AAC5C,MAAIU,UAAU,GAAG,CAAjB;;AACA,OAAK,IAAIP,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,SAAS,CAACV,MAA9B,EAAsCa,CAAC,EAAvC,EAA2C;AAC1CO,IAAAA,UAAU,IAAIV,SAAS,CAACG,CAAD,CAAT,CAAaG,KAA3B;AACA;;AACD,SAAOI,UAAP;AACA;;AAED,SAASlC,2BAAT,CAAqCwB,SAArC,EAAgD;AAC/C,MAAIW,SAAS,GAAG,CAAhB;;AACA,OAAK,IAAIR,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,SAAS,CAACV,MAA9B,EAAsCa,CAAC,EAAvC,EAA2C;AAC1C,QAAIH,SAAS,CAACG,CAAD,CAAT,CAAahB,MAAb,GAAsBwB,SAA1B,EAAqC;AACpCA,MAAAA,SAAS,GAAGX,SAAS,CAACG,CAAD,CAAT,CAAahB,MAAzB;AACA;AACD;;AACD,SAAOwB,SAAP;AACA;;AAED,SAASP,WAAT,CAAqBQ,MAArB,EAA6B1B,OAA7B,EAAsCgB,OAAtC,EAA+C;AAC9C,MAAIW,GAAJ;;AAEA,MAAIX,OAAJ,EAAa;AACZW,IAAAA,GAAG,GAAGX,OAAN;AACA,GAFD,MAEO,IAAI,OAAOY,QAAP,KAAoB,WAAxB,EAAqC;AAC3CD,IAAAA,GAAG,GAAGC,QAAQ,CAACC,aAAT,CAAuB,QAAvB,EAAiCC,UAAjC,CAA4C,IAA5C,CAAN;AACA,GAFM,MAEA;AACN;AACA;AACA,WAAO,CAAP;AACA;;AACDH,EAAAA,GAAG,CAACI,IAAJ,GAAW/B,OAAO,CAACgC,WAAR,GAAsB,GAAtB,GAA4BhC,OAAO,CAACK,QAApC,GAA+C,KAA/C,GAAuDL,OAAO,CAAC+B,IAA1E,CAZ8C,CAc9C;;AACA,MAAIE,iBAAiB,GAAGN,GAAG,CAACO,WAAJ,CAAgBR,MAAhB,CAAxB;;AACA,MAAI,CAACO,iBAAL,EAAwB;AACvB;AACA;AACA;AACA,WAAO,CAAP;AACA;;AACD,MAAIE,IAAI,GAAGF,iBAAiB,CAACb,KAA7B;AACA,SAAOe,IAAP;AACA;;AAEDnD,OAAO,CAACM,2BAAR,GAAsCA,2BAAtC;AACAN,OAAO,CAACK,iBAAR,GAA4BA,iBAA5B;AACAL,OAAO,CAACI,iBAAR,GAA4BA,iBAA5B;AACAJ,OAAO,CAACG,2BAAR,GAAsCA,2BAAtC;AACAH,OAAO,CAACE,wBAAR,GAAmCA,wBAAnC","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.getTotalWidthOfEncodings = exports.calculateEncodingAttributes = exports.getBarcodePadding = exports.getEncodingHeight = exports.getMaximumHeightOfEncodings = undefined;\n\nvar _merge = require(\"../help/merge.js\");\n\nvar _merge2 = _interopRequireDefault(_merge);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction getEncodingHeight(encoding, options) {\n\treturn options.height + (options.displayValue && encoding.text.length > 0 ? options.fontSize + options.textMargin : 0) + options.marginTop + options.marginBottom;\n}\n\nfunction getBarcodePadding(textWidth, barcodeWidth, options) {\n\tif (options.displayValue && barcodeWidth < textWidth) {\n\t\tif (options.textAlign == \"center\") {\n\t\t\treturn Math.floor((textWidth - barcodeWidth) / 2);\n\t\t} else if (options.textAlign == \"left\") {\n\t\t\treturn 0;\n\t\t} else if (options.textAlign == \"right\") {\n\t\t\treturn Math.floor(textWidth - barcodeWidth);\n\t\t}\n\t}\n\treturn 0;\n}\n\nfunction calculateEncodingAttributes(encodings, barcodeOptions, context) {\n\tfor (var i = 0; i < encodings.length; i++) {\n\t\tvar encoding = encodings[i];\n\t\tvar options = (0, _merge2.default)(barcodeOptions, encoding.options);\n\n\t\t// Calculate the width of the encoding\n\t\tvar textWidth;\n\t\tif (options.displayValue) {\n\t\t\ttextWidth = messureText(encoding.text, options, context);\n\t\t} else {\n\t\t\ttextWidth = 0;\n\t\t}\n\n\t\tvar barcodeWidth = encoding.data.length * options.width;\n\t\tencoding.width = Math.ceil(Math.max(textWidth, barcodeWidth));\n\n\t\tencoding.height = getEncodingHeight(encoding, options);\n\n\t\tencoding.barcodePadding = getBarcodePadding(textWidth, barcodeWidth, options);\n\t}\n}\n\nfunction getTotalWidthOfEncodings(encodings) {\n\tvar totalWidth = 0;\n\tfor (var i = 0; i < encodings.length; i++) {\n\t\ttotalWidth += encodings[i].width;\n\t}\n\treturn totalWidth;\n}\n\nfunction getMaximumHeightOfEncodings(encodings) {\n\tvar maxHeight = 0;\n\tfor (var i = 0; i < encodings.length; i++) {\n\t\tif (encodings[i].height > maxHeight) {\n\t\t\tmaxHeight = encodings[i].height;\n\t\t}\n\t}\n\treturn maxHeight;\n}\n\nfunction messureText(string, options, context) {\n\tvar ctx;\n\n\tif (context) {\n\t\tctx = context;\n\t} else if (typeof document !== \"undefined\") {\n\t\tctx = document.createElement(\"canvas\").getContext(\"2d\");\n\t} else {\n\t\t// If the text cannot be messured we will return 0.\n\t\t// This will make some barcode with big text render incorrectly\n\t\treturn 0;\n\t}\n\tctx.font = options.fontOptions + \" \" + options.fontSize + \"px \" + options.font;\n\n\t// Calculate the width of the encoding\n\tvar measureTextResult = ctx.measureText(string);\n\tif (!measureTextResult) {\n\t\t// Some implementations don't implement measureText and return undefined.\n\t\t// If the text cannot be measured we will return 0.\n\t\t// This will make some barcode with big text render incorrectly\n\t\treturn 0;\n\t}\n\tvar size = measureTextResult.width;\n\treturn size;\n}\n\nexports.getMaximumHeightOfEncodings = getMaximumHeightOfEncodings;\nexports.getEncodingHeight = getEncodingHeight;\nexports.getBarcodePadding = getBarcodePadding;\nexports.calculateEncodingAttributes = calculateEncodingAttributes;\nexports.getTotalWidthOfEncodings = getTotalWidthOfEncodings;"]},"metadata":{},"sourceType":"script"}