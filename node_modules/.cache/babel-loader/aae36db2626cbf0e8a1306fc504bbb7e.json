{"ast":null,"code":"var _classCallCheck = require(\"/Users/sirin/go/src/github.com/sirinibin/reactjs-pos/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/sirin/go/src/github.com/sirinibin/reactjs-pos/node_modules/@babel/runtime/helpers/createClass\");\n\nvar iconv = require('iconv-lite');\n\nvar linewrap = require('linewrap');\n\nvar _require = require('canvas'),\n    createCanvas = _require.createCanvas;\n\nvar Dither = require('canvas-dither');\n\nvar Flatten = require('canvas-flatten');\n/**\n * Create a byte stream based on commands for ESC/POS printers\n */\n\n\nvar StarPrntEncoder = /*#__PURE__*/function () {\n  \"use strict\";\n\n  /**\n     * Create a new object\n     *\n    */\n  function StarPrntEncoder() {\n    _classCallCheck(this, StarPrntEncoder);\n\n    this._reset();\n  }\n  /**\n     * Reset the state of the object\n     *\n    */\n\n\n  _createClass(StarPrntEncoder, [{\n    key: \"_reset\",\n    value: function _reset() {\n      this._buffer = [];\n      this._codepage = 'ascii';\n      this._state = {\n        'bold': false,\n        'underline': false\n      };\n    }\n    /**\n       * Encode a string with the current code page\n       *\n       * @param  {string}   value  String to encode\n       * @return {object}          Encoded string as a ArrayBuffer\n       *\n      */\n\n  }, {\n    key: \"_encode\",\n    value: function _encode(value) {\n      return iconv.encode(value, this._codepage);\n    }\n    /**\n       * Add commands to the buffer\n       *\n       * @param  {array}   value  And array of numbers, arrays, buffers or Uint8Arrays to add to the buffer\n       *\n      */\n\n  }, {\n    key: \"_queue\",\n    value: function _queue(value) {\n      var _this = this;\n\n      value.forEach(function (item) {\n        return _this._buffer.push(item);\n      });\n    }\n    /**\n       * Initialize the printer\n       *\n       * @return {object}          Return the object, for easy chaining commands\n       *\n       */\n\n  }, {\n    key: \"initialize\",\n    value: function initialize() {\n      this._queue([0x1b, 0x40, 0x18]);\n\n      return this;\n    }\n    /**\n       * Change the code page\n       *\n       * @param  {string}   value  The codepage that we set the printer to\n       * @return {object}          Return the object, for easy chaining commands\n       *\n       */\n\n  }, {\n    key: \"codepage\",\n    value: function codepage(value) {\n      var codepages = {\n        'cp437': 0x01,\n        'cp858': 0x04,\n        'cp852': 0x05,\n        'cp860': 0x06,\n        'cp861': 0x07,\n        'cp863': 0x08,\n        'cp865': 0x09,\n        'cp866': 0x0a,\n        'cp855': 0x0b,\n        'cp857': 0x0c,\n        'cp862': 0x0d,\n        'cp864': 0x0e,\n        'cp737': 0x0f,\n        'cp869': 0x11,\n        'windows874': 0x14,\n        'windows1252': 0x20,\n        'windows1250': 0x21,\n        'windows1251': 0x22\n      };\n      var codepage;\n\n      if (!iconv.encodingExists(value)) {\n        throw new Error('Unknown codepage');\n      }\n\n      if (value in iconv.encodings) {\n        if (typeof iconv.encodings[value] === 'string') {\n          codepage = iconv.encodings[value];\n        } else {\n          codepage = value;\n        }\n      } else {\n        throw new Error('Unknown codepage');\n      }\n\n      if (typeof codepages[codepage] !== 'undefined') {\n        this._codepage = codepage;\n\n        this._queue([0x1b, 0x1d, 0x74, codepages[codepage]]);\n      } else {\n        throw new Error('Codepage not supported by printer');\n      }\n\n      return this;\n    }\n    /**\n       * Print text\n       *\n       * @param  {string}   value  Text that needs to be printed\n       * @param  {number}   wrap   Wrap text after this many positions\n       * @return {object}          Return the object, for easy chaining commands\n       *\n       */\n\n  }, {\n    key: \"text\",\n    value: function text(value, wrap) {\n      if (wrap) {\n        var w = linewrap(wrap, {\n          lineBreak: '\\r\\n'\n        });\n        value = w(value);\n      }\n\n      var bytes = this._encode(value);\n\n      this._queue([bytes]);\n\n      return this;\n    }\n    /**\n       * Print a newline\n       *\n       * @return {object}          Return the object, for easy chaining commands\n       *\n       */\n\n  }, {\n    key: \"newline\",\n    value: function newline() {\n      this._queue([0x0a, 0x0d]);\n\n      return this;\n    }\n    /**\n       * Print text, followed by a newline\n       *\n       * @param  {string}   value  Text that needs to be printed\n       * @param  {number}   wrap   Wrap text after this many positions\n       * @return {object}          Return the object, for easy chaining commands\n       *\n       */\n\n  }, {\n    key: \"line\",\n    value: function line(value, wrap) {\n      this.text(value, wrap);\n      this.newline();\n      return this;\n    }\n    /**\n       * Underline text\n       *\n       * @param  {boolean|number}   value  true to turn on underline, false to turn off\n       * @return {object}                  Return the object, for easy chaining commands\n       *\n       */\n\n  }, {\n    key: \"underline\",\n    value: function underline(value) {\n      if (typeof value === 'undefined') {\n        value = !this._state.underline;\n      }\n\n      this._state.underline = value;\n\n      this._queue([0x1b, 0x2d, Number(value)]);\n\n      return this;\n    }\n    /**\n       * Italic text\n       * This is a no-op for StarPRNT, as this is not supported by printers.\n       * This function is for compatibility with EscPosEncoder, which does support italic.\n       *\n       * @param  {boolean}          value  true to turn on italic, false to turn off\n       * @return {object}                  Return the object, for easy chaining commands\n       *\n       */\n\n  }, {\n    key: \"italic\",\n    value: function italic(value) {\n      return this;\n    }\n    /**\n       * Bold text\n       *\n       * @param  {boolean}          value  true to turn on bold, false to turn off\n       * @return {object}                  Return the object, for easy chaining commands\n       *\n       */\n\n  }, {\n    key: \"bold\",\n    value: function bold(value) {\n      if (typeof value === 'undefined') {\n        value = !this._state.bold;\n      }\n\n      this._state.bold = value;\n\n      if (value) {\n        this._queue([0x1b, 0x45]);\n      } else {\n        this._queue([0x1b, 0x46]);\n      }\n\n      return this;\n    }\n    /**\n       * Change text size\n       *\n       * @param  {string}          value   smaller, small or normal\n       * @return {object}                  Return the object, for easy chaining commands\n       *\n       */\n\n  }, {\n    key: \"size\",\n    value: function size(value) {\n      if (value === 'smaller') {\n        value = 0x02;\n      } else if (value === 'small') {\n        value = 0x01;\n      } else {\n        value = 0x00;\n      }\n\n      this._queue([0x1b, 0x1e, 0x46, value]);\n\n      return this;\n    }\n    /**\n       * Change text alignment\n       *\n       * @param  {string}          value   left, center or right\n       * @return {object}                  Return the object, for easy chaining commands\n       *\n       */\n\n  }, {\n    key: \"align\",\n    value: function align(value) {\n      var alignments = {\n        'left': 0x00,\n        'center': 0x01,\n        'right': 0x02\n      };\n\n      if (value in alignments) {\n        this._queue([0x1b, 0x1d, 0x61, alignments[value]]);\n      } else {\n        throw new Error('Unknown alignment');\n      }\n\n      return this;\n    }\n    /**\n       * Barcode\n       *\n       * @param  {string}           value  the value of the barcode\n       * @param  {string}           symbology  the type of the barcode\n       * @param  {number}           height  height of the barcode\n       * @return {object}                  Return the object, for easy chaining commands\n       *\n       */\n\n  }, {\n    key: \"barcode\",\n    value: function barcode(value, symbology, height) {\n      var symbologies = {\n        'upce': 0x00,\n        'upca': 0x01,\n        'ean8': 0x02,\n        'ean13': 0x03,\n        'code39': 0x04,\n        'itf': 0x05,\n        'code128': 0x06,\n        'code93': 0x07,\n        'nw-7': 0x08,\n        'gs1-128': 0x09,\n        'gs1-databar-omni': 0x0a,\n        'gs1-databar-truncated': 0x0b,\n        'gs1-databar-limited': 0x0c,\n        'gs1-databar-expanded': 0x0d\n      };\n\n      if (symbology in symbologies) {\n        var bytes = iconv.encode(value, 'ascii');\n\n        this._queue([0x1b, 0x62, symbologies[symbology], 0x01, 0x03, height, bytes, 0x1e]);\n      } else {\n        throw new Error('Symbology not supported by printer');\n      }\n\n      return this;\n    }\n    /**\n       * QR code\n       *\n       * @param  {string}           value  the value of the qr code\n       * @param  {number}           model  model of the qrcode, either 1 or 2\n       * @param  {number}           size   size of the qrcode, a value between 1 and 8\n       * @param  {string}           errorlevel  the amount of error correction used, either 'l', 'm', 'q', 'h'\n       * @return {object}                  Return the object, for easy chaining commands\n       *\n       */\n\n  }, {\n    key: \"qrcode\",\n    value: function qrcode(value, model, size, errorlevel) {\n      /* Force printing the print buffer and moving to a new line */\n      this._queue([0x0a]);\n      /* Model */\n\n\n      var models = {\n        1: 0x01,\n        2: 0x02\n      };\n\n      if (typeof model === 'undefined') {\n        model = 2;\n      }\n\n      if (model in models) {\n        this._queue([0x1b, 0x1d, 0x79, 0x53, 0x30, models[model]]);\n      } else {\n        throw new Error('Model must be 1 or 2');\n      }\n      /* Size */\n\n\n      if (typeof size === 'undefined') {\n        size = 6;\n      }\n\n      if (typeof size !== 'number') {\n        throw new Error('Size must be a number');\n      }\n\n      if (size < 1 || size > 8) {\n        throw new Error('Size must be between 1 and 8');\n      }\n\n      this._queue([0x1b, 0x1d, 0x79, 0x53, 0x32, size]);\n      /* Error level */\n\n\n      var errorlevels = {\n        'l': 0x00,\n        'm': 0x01,\n        'q': 0x02,\n        'h': 0x03\n      };\n\n      if (typeof errorlevel === 'undefined') {\n        errorlevel = 'm';\n      }\n\n      if (errorlevel in errorlevels) {\n        this._queue([0x1b, 0x1d, 0x79, 0x53, 0x31, errorlevels[errorlevel]]);\n      } else {\n        throw new Error('Error level must be l, m, q or h');\n      }\n      /* Data */\n\n\n      var bytes = iconv.encode(value, 'iso88591');\n      var length = bytes.length; // + 3;\n\n      this._queue([0x1b, 0x1d, 0x79, 0x44, 0x31, 0x00, length % 0xff, length / 0xff, bytes // 0x1b, 0x1d, 0x79, 0x33, 0x31, 0x00, length % 0xff, length / 0xff, bytes\n      // 0x1d, 0x28, 0x6b, length % 0xff, length / 0xff, 0x31, 0x50, 0x30, bytes,\n      ]);\n      /* Print QR code */\n\n\n      this._queue([0x1b, 0x1d, 0x79, 0x50]);\n\n      return this;\n    }\n    /**\n       * Image\n       *\n       * @param  {object}         element  an element, like a canvas or image that needs to be printed\n       * @param  {number}         width  width of the image on the printer\n       * @param  {number}         height  height of the image on the printer\n       * @param  {string}         algorithm  the dithering algorithm for making the image black and white\n       * @param  {number}         threshold  threshold for the dithering algorithm\n       * @return {object}                  Return the object, for easy chaining commands\n       *\n       */\n\n  }, {\n    key: \"image\",\n    value: function image(element, width, height, algorithm, threshold) {\n      if (width % 8 !== 0) {\n        throw new Error('Width must be a multiple of 8');\n      }\n\n      if (height % 24 !== 0) {\n        throw new Error('Height must be a multiple of 24');\n      }\n\n      if (typeof algorithm === 'undefined') {\n        algorithm = 'threshold';\n      }\n\n      if (typeof threshold === 'undefined') {\n        threshold = 128;\n      }\n\n      var canvas = createCanvas(width, height);\n      var context = canvas.getContext('2d');\n      context.drawImage(element, 0, 0, width, height);\n      var image = context.getImageData(0, 0, width, height);\n      image = Flatten.flatten(image, [0xff, 0xff, 0xff]);\n\n      switch (algorithm) {\n        case 'threshold':\n          image = Dither.threshold(image, threshold);\n          break;\n\n        case 'bayer':\n          image = Dither.bayer(image, threshold);\n          break;\n\n        case 'floydsteinberg':\n          image = Dither.floydsteinberg(image);\n          break;\n\n        case 'atkinson':\n          image = Dither.atkinson(image);\n          break;\n      }\n\n      var getPixel = function getPixel(x, y) {\n        return image.data[(width * y + x) * 4] > 0 ? 0 : 1;\n      };\n\n      this._queue([0x1b, 0x30]);\n\n      for (var s = 0; s < height / 24; s++) {\n        var y = s * 24;\n        var bytes = new Uint8Array(width * 3);\n\n        for (var x = 0; x < width; x++) {\n          var i = x * 3;\n          bytes[i] = getPixel(x, y + 0) << 7 | getPixel(x, y + 1) << 6 | getPixel(x, y + 2) << 5 | getPixel(x, y + 3) << 4 | getPixel(x, y + 4) << 3 | getPixel(x, y + 5) << 2 | getPixel(x, y + 6) << 1 | getPixel(x, y + 7);\n          bytes[i + 1] = getPixel(x, y + 8) << 7 | getPixel(x, y + 9) << 6 | getPixel(x, y + 10) << 5 | getPixel(x, y + 11) << 4 | getPixel(x, y + 12) << 3 | getPixel(x, y + 13) << 2 | getPixel(x, y + 14) << 1 | getPixel(x, y + 15);\n          bytes[i + 2] = getPixel(x, y + 16) << 7 | getPixel(x, y + 17) << 6 | getPixel(x, y + 18) << 5 | getPixel(x, y + 19) << 4 | getPixel(x, y + 20) << 3 | getPixel(x, y + 21) << 2 | getPixel(x, y + 22) << 1 | getPixel(x, y + 23);\n        }\n\n        this._queue([0x1b, 0x58, width & 0xff, width >> 8 & 0xff, bytes, 0x0a, 0x0d]);\n      }\n\n      this._queue([0x1b, 0x7a, 0x01]);\n\n      return this;\n    }\n    /**\n       * Cut paper\n       *\n       * @param  {string}          value   full or partial. When not specified a full cut will be assumed\n       * @return {object}                  Return the object, for easy chaining commands\n       *\n       */\n\n  }, {\n    key: \"cut\",\n    value: function cut(value) {\n      var data = 0x00;\n\n      if (value == 'partial') {\n        data = 0x01;\n      }\n\n      this._queue([0x1b, 0x64, data]);\n\n      return this;\n    }\n    /**\n       * Add raw printer commands\n       *\n       * @param  {array}           data   raw bytes to be included\n       * @return {object}          Return the object, for easy chaining commands\n       *\n       */\n\n  }, {\n    key: \"raw\",\n    value: function raw(data) {\n      this._queue(data);\n\n      return this;\n    }\n    /**\n       * Encode all previous commands\n       *\n       * @return {Uint8Array}         Return the encoded bytes\n       *\n       */\n\n  }, {\n    key: \"encode\",\n    value: function encode() {\n      var length = 0;\n\n      this._buffer.forEach(function (item) {\n        if (typeof item === 'number') {\n          length++;\n        } else {\n          length += item.length;\n        }\n      });\n\n      var result = new Uint8Array(length);\n      var index = 0;\n\n      this._buffer.forEach(function (item) {\n        if (typeof item === 'number') {\n          result[index] = item;\n          index++;\n        } else {\n          result.set(item, index);\n          index += item.length;\n        }\n      });\n\n      this._reset();\n\n      return result;\n    }\n  }]);\n\n  return StarPrntEncoder;\n}();\n\nmodule.exports = StarPrntEncoder;","map":{"version":3,"sources":["/Users/sirin/go/src/github.com/sirinibin/reactjs-pos/node_modules/star-prnt-encoder/src/star-prnt-encoder.js"],"names":["iconv","require","linewrap","createCanvas","Dither","Flatten","StarPrntEncoder","_reset","_buffer","_codepage","_state","value","encode","forEach","item","push","_queue","codepages","codepage","encodingExists","Error","encodings","wrap","w","lineBreak","bytes","_encode","text","newline","underline","Number","bold","alignments","symbology","height","symbologies","model","size","errorlevel","models","errorlevels","length","element","width","algorithm","threshold","canvas","context","getContext","drawImage","image","getImageData","flatten","bayer","floydsteinberg","atkinson","getPixel","x","y","data","s","Uint8Array","i","result","index","set","module","exports"],"mappings":"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","sourcesContent":["const iconv = require('iconv-lite');\nconst linewrap = require('linewrap');\nconst {createCanvas} = require('canvas');\nconst Dither = require('canvas-dither');\nconst Flatten = require('canvas-flatten');\n\n\n/**\n * Create a byte stream based on commands for ESC/POS printers\n */\nclass StarPrntEncoder {\n  /**\n     * Create a new object\n     *\n    */\n  constructor() {\n    this._reset();\n  }\n\n  /**\n     * Reset the state of the object\n     *\n    */\n  _reset() {\n    this._buffer = [];\n    this._codepage = 'ascii';\n\n    this._state = {\n      'bold': false,\n      'underline': false,\n    };\n  }\n\n  /**\n     * Encode a string with the current code page\n     *\n     * @param  {string}   value  String to encode\n     * @return {object}          Encoded string as a ArrayBuffer\n     *\n    */\n  _encode(value) {\n    return iconv.encode(value, this._codepage);\n  }\n\n  /**\n     * Add commands to the buffer\n     *\n     * @param  {array}   value  And array of numbers, arrays, buffers or Uint8Arrays to add to the buffer\n     *\n    */\n  _queue(value) {\n    value.forEach((item) => this._buffer.push(item));\n  }\n\n  /**\n     * Initialize the printer\n     *\n     * @return {object}          Return the object, for easy chaining commands\n     *\n     */\n  initialize() {\n    this._queue([\n      0x1b, 0x40, 0x18,\n    ]);\n\n    return this;\n  }\n\n  /**\n     * Change the code page\n     *\n     * @param  {string}   value  The codepage that we set the printer to\n     * @return {object}          Return the object, for easy chaining commands\n     *\n     */\n  codepage(value) {\n    const codepages = {\n      'cp437': 0x01,\n      'cp858': 0x04,\n      'cp852': 0x05,\n      'cp860': 0x06,\n      'cp861': 0x07,\n      'cp863': 0x08,\n      'cp865': 0x09,\n      'cp866': 0x0a,\n      'cp855': 0x0b,\n      'cp857': 0x0c,\n      'cp862': 0x0d,\n      'cp864': 0x0e,\n      'cp737': 0x0f,\n      'cp869': 0x11,\n      'windows874': 0x14,\n      'windows1252': 0x20,\n      'windows1250': 0x21,\n      'windows1251': 0x22,\n    };\n\n    let codepage;\n\n    if (!iconv.encodingExists(value)) {\n      throw new Error('Unknown codepage');\n    }\n\n    if (value in iconv.encodings) {\n      if (typeof iconv.encodings[value] === 'string') {\n        codepage = iconv.encodings[value];\n      } else {\n        codepage = value;\n      }\n    } else {\n      throw new Error('Unknown codepage');\n    }\n\n    if (typeof codepages[codepage] !== 'undefined') {\n      this._codepage = codepage;\n\n      this._queue([\n        0x1b, 0x1d, 0x74, codepages[codepage],\n      ]);\n    } else {\n      throw new Error('Codepage not supported by printer');\n    }\n\n    return this;\n  }\n\n  /**\n     * Print text\n     *\n     * @param  {string}   value  Text that needs to be printed\n     * @param  {number}   wrap   Wrap text after this many positions\n     * @return {object}          Return the object, for easy chaining commands\n     *\n     */\n  text(value, wrap) {\n    if (wrap) {\n      const w = linewrap(wrap, {lineBreak: '\\r\\n'});\n      value = w(value);\n    }\n\n    const bytes = this._encode(value);\n\n    this._queue([\n      bytes,\n    ]);\n\n    return this;\n  }\n\n  /**\n     * Print a newline\n     *\n     * @return {object}          Return the object, for easy chaining commands\n     *\n     */\n  newline() {\n    this._queue([\n      0x0a, 0x0d,\n    ]);\n\n    return this;\n  }\n\n  /**\n     * Print text, followed by a newline\n     *\n     * @param  {string}   value  Text that needs to be printed\n     * @param  {number}   wrap   Wrap text after this many positions\n     * @return {object}          Return the object, for easy chaining commands\n     *\n     */\n  line(value, wrap) {\n    this.text(value, wrap);\n    this.newline();\n\n    return this;\n  }\n\n  /**\n     * Underline text\n     *\n     * @param  {boolean|number}   value  true to turn on underline, false to turn off\n     * @return {object}                  Return the object, for easy chaining commands\n     *\n     */\n  underline(value) {\n    if (typeof value === 'undefined') {\n      value = ! this._state.underline;\n    }\n\n    this._state.underline = value;\n\n    this._queue([\n      0x1b, 0x2d, Number(value),\n    ]);\n\n    return this;\n  }\n\n  /**\n     * Italic text\n     * This is a no-op for StarPRNT, as this is not supported by printers.\n     * This function is for compatibility with EscPosEncoder, which does support italic.\n     *\n     * @param  {boolean}          value  true to turn on italic, false to turn off\n     * @return {object}                  Return the object, for easy chaining commands\n     *\n     */\n  italic(value) {\n    return this;\n  }\n\n  /**\n     * Bold text\n     *\n     * @param  {boolean}          value  true to turn on bold, false to turn off\n     * @return {object}                  Return the object, for easy chaining commands\n     *\n     */\n  bold(value) {\n    if (typeof value === 'undefined') {\n      value = ! this._state.bold;\n    }\n\n    this._state.bold = value;\n\n    if (value) {\n      this._queue([\n        0x1b, 0x45,\n      ]);\n    } else {\n      this._queue([\n        0x1b, 0x46,\n      ]);\n    }\n\n    return this;\n  }\n\n  /**\n     * Change text size\n     *\n     * @param  {string}          value   smaller, small or normal\n     * @return {object}                  Return the object, for easy chaining commands\n     *\n     */\n  size(value) {\n    if (value === 'smaller') {\n      value = 0x02;\n    } else if (value === 'small') {\n      value = 0x01;\n    } else {\n      value = 0x00;\n    }\n\n    this._queue([\n      0x1b, 0x1e, 0x46, value,\n    ]);\n\n    return this;\n  }\n\n  /**\n     * Change text alignment\n     *\n     * @param  {string}          value   left, center or right\n     * @return {object}                  Return the object, for easy chaining commands\n     *\n     */\n  align(value) {\n    const alignments = {\n      'left': 0x00,\n      'center': 0x01,\n      'right': 0x02,\n    };\n\n    if (value in alignments) {\n      this._queue([\n        0x1b, 0x1d, 0x61, alignments[value],\n      ]);\n    } else {\n      throw new Error('Unknown alignment');\n    }\n\n    return this;\n  }\n\n  /**\n     * Barcode\n     *\n     * @param  {string}           value  the value of the barcode\n     * @param  {string}           symbology  the type of the barcode\n     * @param  {number}           height  height of the barcode\n     * @return {object}                  Return the object, for easy chaining commands\n     *\n     */\n  barcode(value, symbology, height) {\n    const symbologies = {\n      'upce': 0x00,\n      'upca': 0x01,\n      'ean8': 0x02,\n      'ean13': 0x03,\n      'code39': 0x04,\n      'itf': 0x05,\n      'code128': 0x06,\n      'code93': 0x07,\n      'nw-7': 0x08,\n      'gs1-128': 0x09,\n      'gs1-databar-omni': 0x0a,\n      'gs1-databar-truncated': 0x0b,\n      'gs1-databar-limited': 0x0c,\n      'gs1-databar-expanded': 0x0d,\n    };\n\n    if (symbology in symbologies) {\n      const bytes = iconv.encode(value, 'ascii');\n\n      this._queue([\n        0x1b, 0x62,\n        symbologies[symbology], 0x01, 0x03, height,\n        bytes, 0x1e,\n      ]);\n    } else {\n      throw new Error('Symbology not supported by printer');\n    }\n\n    return this;\n  }\n\n  /**\n     * QR code\n     *\n     * @param  {string}           value  the value of the qr code\n     * @param  {number}           model  model of the qrcode, either 1 or 2\n     * @param  {number}           size   size of the qrcode, a value between 1 and 8\n     * @param  {string}           errorlevel  the amount of error correction used, either 'l', 'm', 'q', 'h'\n     * @return {object}                  Return the object, for easy chaining commands\n     *\n     */\n  qrcode(value, model, size, errorlevel) {\n    /* Force printing the print buffer and moving to a new line */\n\n    this._queue([\n      0x0a,\n    ]);\n\n    /* Model */\n\n    const models = {\n      1: 0x01,\n      2: 0x02,\n    };\n\n    if (typeof model === 'undefined') {\n      model = 2;\n    }\n\n    if (model in models) {\n      this._queue([\n        0x1b, 0x1d, 0x79, 0x53, 0x30, models[model],\n      ]);\n    } else {\n      throw new Error('Model must be 1 or 2');\n    }\n\n    /* Size */\n\n    if (typeof size === 'undefined') {\n      size = 6;\n    }\n\n    if (typeof size !== 'number') {\n      throw new Error('Size must be a number');\n    }\n\n    if (size < 1 || size > 8) {\n      throw new Error('Size must be between 1 and 8');\n    }\n\n    this._queue([\n      0x1b, 0x1d, 0x79, 0x53, 0x32, size,\n    ]);\n\n    /* Error level */\n\n    const errorlevels = {\n      'l': 0x00,\n      'm': 0x01,\n      'q': 0x02,\n      'h': 0x03,\n    };\n\n    if (typeof errorlevel === 'undefined') {\n      errorlevel = 'm';\n    }\n\n    if (errorlevel in errorlevels) {\n      this._queue([\n        0x1b, 0x1d, 0x79, 0x53, 0x31, errorlevels[errorlevel],\n      ]);\n    } else {\n      throw new Error('Error level must be l, m, q or h');\n    }\n\n    /* Data */\n\n    const bytes = iconv.encode(value, 'iso88591');\n    const length = bytes.length; // + 3;\n\n    this._queue([\n      0x1b, 0x1d, 0x79, 0x44, 0x31, 0x00, length % 0xff, length / 0xff, bytes,\n      // 0x1b, 0x1d, 0x79, 0x33, 0x31, 0x00, length % 0xff, length / 0xff, bytes\n      // 0x1d, 0x28, 0x6b, length % 0xff, length / 0xff, 0x31, 0x50, 0x30, bytes,\n    ]);\n\n    /* Print QR code */\n\n    this._queue([\n      0x1b, 0x1d, 0x79, 0x50,\n    ]);\n\n    return this;\n  }\n\n  /**\n     * Image\n     *\n     * @param  {object}         element  an element, like a canvas or image that needs to be printed\n     * @param  {number}         width  width of the image on the printer\n     * @param  {number}         height  height of the image on the printer\n     * @param  {string}         algorithm  the dithering algorithm for making the image black and white\n     * @param  {number}         threshold  threshold for the dithering algorithm\n     * @return {object}                  Return the object, for easy chaining commands\n     *\n     */\n  image(element, width, height, algorithm, threshold) {\n    if (width % 8 !== 0) {\n      throw new Error('Width must be a multiple of 8');\n    }\n\n    if (height % 24 !== 0) {\n      throw new Error('Height must be a multiple of 24');\n    }\n\n    if (typeof algorithm === 'undefined') {\n      algorithm = 'threshold';\n    }\n\n    if (typeof threshold === 'undefined') {\n      threshold = 128;\n    }\n\n    const canvas = createCanvas(width, height);\n    const context = canvas.getContext('2d');\n    context.drawImage(element, 0, 0, width, height);\n    let image = context.getImageData(0, 0, width, height);\n\n    image = Flatten.flatten(image, [0xff, 0xff, 0xff]);\n\n    switch (algorithm) {\n      case 'threshold': image = Dither.threshold(image, threshold); break;\n      case 'bayer': image = Dither.bayer(image, threshold); break;\n      case 'floydsteinberg': image = Dither.floydsteinberg(image); break;\n      case 'atkinson': image = Dither.atkinson(image); break;\n    }\n\n    const getPixel = (x, y) => image.data[((width * y) + x) * 4] > 0 ? 0 : 1;\n\n\n    this._queue([\n      0x1b, 0x30,\n    ]);\n\n    for (let s = 0; s < height / 24; s++) {\n      const y = s * 24;\n      const bytes = new Uint8Array(width * 3);\n\n      for (let x = 0; x < width; x++) {\n        const i = x * 3;\n\n        bytes[i] =\n            getPixel(x, y + 0) << 7 |\n            getPixel(x, y + 1) << 6 |\n            getPixel(x, y + 2) << 5 |\n            getPixel(x, y + 3) << 4 |\n            getPixel(x, y + 4) << 3 |\n            getPixel(x, y + 5) << 2 |\n            getPixel(x, y + 6) << 1 |\n            getPixel(x, y + 7);\n\n        bytes[i + 1] =\n            getPixel(x, y + 8) << 7 |\n            getPixel(x, y + 9) << 6 |\n            getPixel(x, y + 10) << 5 |\n            getPixel(x, y + 11) << 4 |\n            getPixel(x, y + 12) << 3 |\n            getPixel(x, y + 13) << 2 |\n            getPixel(x, y + 14) << 1 |\n            getPixel(x, y + 15);\n\n        bytes[i + 2] =\n            getPixel(x, y + 16) << 7 |\n            getPixel(x, y + 17) << 6 |\n            getPixel(x, y + 18) << 5 |\n            getPixel(x, y + 19) << 4 |\n            getPixel(x, y + 20) << 3 |\n            getPixel(x, y + 21) << 2 |\n            getPixel(x, y + 22) << 1 |\n            getPixel(x, y + 23);\n      }\n\n      this._queue([\n        0x1b, 0x58,\n        width & 0xff, ((width >> 8) & 0xff),\n        bytes,\n        0x0a, 0x0d,\n      ]);\n    }\n\n    this._queue([\n      0x1b, 0x7a, 0x01,\n    ]);\n\n    return this;\n  }\n\n  /**\n     * Cut paper\n     *\n     * @param  {string}          value   full or partial. When not specified a full cut will be assumed\n     * @return {object}                  Return the object, for easy chaining commands\n     *\n     */\n  cut(value) {\n    let data = 0x00;\n\n    if (value == 'partial') {\n      data = 0x01;\n    }\n\n    this._queue([\n      0x1b, 0x64, data,\n    ]);\n\n    return this;\n  }\n\n  /**\n     * Add raw printer commands\n     *\n     * @param  {array}           data   raw bytes to be included\n     * @return {object}          Return the object, for easy chaining commands\n     *\n     */\n  raw(data) {\n    this._queue(data);\n\n    return this;\n  }\n\n  /**\n     * Encode all previous commands\n     *\n     * @return {Uint8Array}         Return the encoded bytes\n     *\n     */\n  encode() {\n    let length = 0;\n\n    this._buffer.forEach((item) => {\n      if (typeof item === 'number') {\n        length++;\n      } else {\n        length += item.length;\n      }\n    });\n\n    const result = new Uint8Array(length);\n\n    let index = 0;\n\n    this._buffer.forEach((item) => {\n      if (typeof item === 'number') {\n        result[index] = item;\n        index++;\n      } else {\n        result.set(item, index);\n        index += item.length;\n      }\n    });\n\n    this._reset();\n\n    return result;\n  }\n}\n\nmodule.exports = StarPrntEncoder;\n"]},"metadata":{},"sourceType":"script"}