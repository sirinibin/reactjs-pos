{"ast":null,"code":"const iconv = require('iconv-lite');\n\nconst linewrap = require('linewrap');\n\nconst {\n  createCanvas\n} = require('canvas');\n\nconst Dither = require('canvas-dither');\n\nconst Flatten = require('canvas-flatten');\n/**\n * Create a byte stream based on commands for ESC/POS printers\n */\n\n\nclass StarPrntEncoder {\n  /**\n     * Create a new object\n     *\n    */\n  constructor() {\n    this._reset();\n  }\n  /**\n     * Reset the state of the object\n     *\n    */\n\n\n  _reset() {\n    this._buffer = [];\n    this._codepage = 'ascii';\n    this._state = {\n      'bold': false,\n      'underline': false\n    };\n  }\n  /**\n     * Encode a string with the current code page\n     *\n     * @param  {string}   value  String to encode\n     * @return {object}          Encoded string as a ArrayBuffer\n     *\n    */\n\n\n  _encode(value) {\n    return iconv.encode(value, this._codepage);\n  }\n  /**\n     * Add commands to the buffer\n     *\n     * @param  {array}   value  And array of numbers, arrays, buffers or Uint8Arrays to add to the buffer\n     *\n    */\n\n\n  _queue(value) {\n    value.forEach(item => this._buffer.push(item));\n  }\n  /**\n     * Initialize the printer\n     *\n     * @return {object}          Return the object, for easy chaining commands\n     *\n     */\n\n\n  initialize() {\n    this._queue([0x1b, 0x40, 0x18]);\n\n    return this;\n  }\n  /**\n     * Change the code page\n     *\n     * @param  {string}   value  The codepage that we set the printer to\n     * @return {object}          Return the object, for easy chaining commands\n     *\n     */\n\n\n  codepage(value) {\n    const codepages = {\n      'cp437': 0x01,\n      'cp858': 0x04,\n      'cp852': 0x05,\n      'cp860': 0x06,\n      'cp861': 0x07,\n      'cp863': 0x08,\n      'cp865': 0x09,\n      'cp866': 0x0a,\n      'cp855': 0x0b,\n      'cp857': 0x0c,\n      'cp862': 0x0d,\n      'cp864': 0x0e,\n      'cp737': 0x0f,\n      'cp869': 0x11,\n      'windows874': 0x14,\n      'windows1252': 0x20,\n      'windows1250': 0x21,\n      'windows1251': 0x22\n    };\n    let codepage;\n\n    if (!iconv.encodingExists(value)) {\n      throw new Error('Unknown codepage');\n    }\n\n    if (value in iconv.encodings) {\n      if (typeof iconv.encodings[value] === 'string') {\n        codepage = iconv.encodings[value];\n      } else {\n        codepage = value;\n      }\n    } else {\n      throw new Error('Unknown codepage');\n    }\n\n    if (typeof codepages[codepage] !== 'undefined') {\n      this._codepage = codepage;\n\n      this._queue([0x1b, 0x1d, 0x74, codepages[codepage]]);\n    } else {\n      throw new Error('Codepage not supported by printer');\n    }\n\n    return this;\n  }\n  /**\n     * Print text\n     *\n     * @param  {string}   value  Text that needs to be printed\n     * @param  {number}   wrap   Wrap text after this many positions\n     * @return {object}          Return the object, for easy chaining commands\n     *\n     */\n\n\n  text(value, wrap) {\n    if (wrap) {\n      const w = linewrap(wrap, {\n        lineBreak: '\\r\\n'\n      });\n      value = w(value);\n    }\n\n    const bytes = this._encode(value);\n\n    this._queue([bytes]);\n\n    return this;\n  }\n  /**\n     * Print a newline\n     *\n     * @return {object}          Return the object, for easy chaining commands\n     *\n     */\n\n\n  newline() {\n    this._queue([0x0a, 0x0d]);\n\n    return this;\n  }\n  /**\n     * Print text, followed by a newline\n     *\n     * @param  {string}   value  Text that needs to be printed\n     * @param  {number}   wrap   Wrap text after this many positions\n     * @return {object}          Return the object, for easy chaining commands\n     *\n     */\n\n\n  line(value, wrap) {\n    this.text(value, wrap);\n    this.newline();\n    return this;\n  }\n  /**\n     * Underline text\n     *\n     * @param  {boolean|number}   value  true to turn on underline, false to turn off\n     * @return {object}                  Return the object, for easy chaining commands\n     *\n     */\n\n\n  underline(value) {\n    if (typeof value === 'undefined') {\n      value = !this._state.underline;\n    }\n\n    this._state.underline = value;\n\n    this._queue([0x1b, 0x2d, Number(value)]);\n\n    return this;\n  }\n  /**\n     * Italic text\n     * This is a no-op for StarPRNT, as this is not supported by printers.\n     * This function is for compatibility with EscPosEncoder, which does support italic.\n     *\n     * @param  {boolean}          value  true to turn on italic, false to turn off\n     * @return {object}                  Return the object, for easy chaining commands\n     *\n     */\n\n\n  italic(value) {\n    return this;\n  }\n  /**\n     * Bold text\n     *\n     * @param  {boolean}          value  true to turn on bold, false to turn off\n     * @return {object}                  Return the object, for easy chaining commands\n     *\n     */\n\n\n  bold(value) {\n    if (typeof value === 'undefined') {\n      value = !this._state.bold;\n    }\n\n    this._state.bold = value;\n\n    if (value) {\n      this._queue([0x1b, 0x45]);\n    } else {\n      this._queue([0x1b, 0x46]);\n    }\n\n    return this;\n  }\n  /**\n     * Change text size\n     *\n     * @param  {string}          value   smaller, small or normal\n     * @return {object}                  Return the object, for easy chaining commands\n     *\n     */\n\n\n  size(value) {\n    if (value === 'smaller') {\n      value = 0x02;\n    } else if (value === 'small') {\n      value = 0x01;\n    } else {\n      value = 0x00;\n    }\n\n    this._queue([0x1b, 0x1e, 0x46, value]);\n\n    return this;\n  }\n  /**\n     * Change text alignment\n     *\n     * @param  {string}          value   left, center or right\n     * @return {object}                  Return the object, for easy chaining commands\n     *\n     */\n\n\n  align(value) {\n    const alignments = {\n      'left': 0x00,\n      'center': 0x01,\n      'right': 0x02\n    };\n\n    if (value in alignments) {\n      this._queue([0x1b, 0x1d, 0x61, alignments[value]]);\n    } else {\n      throw new Error('Unknown alignment');\n    }\n\n    return this;\n  }\n  /**\n     * Barcode\n     *\n     * @param  {string}           value  the value of the barcode\n     * @param  {string}           symbology  the type of the barcode\n     * @param  {number}           height  height of the barcode\n     * @return {object}                  Return the object, for easy chaining commands\n     *\n     */\n\n\n  barcode(value, symbology, height) {\n    const symbologies = {\n      'upce': 0x00,\n      'upca': 0x01,\n      'ean8': 0x02,\n      'ean13': 0x03,\n      'code39': 0x04,\n      'itf': 0x05,\n      'code128': 0x06,\n      'code93': 0x07,\n      'nw-7': 0x08,\n      'gs1-128': 0x09,\n      'gs1-databar-omni': 0x0a,\n      'gs1-databar-truncated': 0x0b,\n      'gs1-databar-limited': 0x0c,\n      'gs1-databar-expanded': 0x0d\n    };\n\n    if (symbology in symbologies) {\n      const bytes = iconv.encode(value, 'ascii');\n\n      this._queue([0x1b, 0x62, symbologies[symbology], 0x01, 0x03, height, bytes, 0x1e]);\n    } else {\n      throw new Error('Symbology not supported by printer');\n    }\n\n    return this;\n  }\n  /**\n     * QR code\n     *\n     * @param  {string}           value  the value of the qr code\n     * @param  {number}           model  model of the qrcode, either 1 or 2\n     * @param  {number}           size   size of the qrcode, a value between 1 and 8\n     * @param  {string}           errorlevel  the amount of error correction used, either 'l', 'm', 'q', 'h'\n     * @return {object}                  Return the object, for easy chaining commands\n     *\n     */\n\n\n  qrcode(value, model, size, errorlevel) {\n    /* Force printing the print buffer and moving to a new line */\n    this._queue([0x0a]);\n    /* Model */\n\n\n    const models = {\n      1: 0x01,\n      2: 0x02\n    };\n\n    if (typeof model === 'undefined') {\n      model = 2;\n    }\n\n    if (model in models) {\n      this._queue([0x1b, 0x1d, 0x79, 0x53, 0x30, models[model]]);\n    } else {\n      throw new Error('Model must be 1 or 2');\n    }\n    /* Size */\n\n\n    if (typeof size === 'undefined') {\n      size = 6;\n    }\n\n    if (typeof size !== 'number') {\n      throw new Error('Size must be a number');\n    }\n\n    if (size < 1 || size > 8) {\n      throw new Error('Size must be between 1 and 8');\n    }\n\n    this._queue([0x1b, 0x1d, 0x79, 0x53, 0x32, size]);\n    /* Error level */\n\n\n    const errorlevels = {\n      'l': 0x00,\n      'm': 0x01,\n      'q': 0x02,\n      'h': 0x03\n    };\n\n    if (typeof errorlevel === 'undefined') {\n      errorlevel = 'm';\n    }\n\n    if (errorlevel in errorlevels) {\n      this._queue([0x1b, 0x1d, 0x79, 0x53, 0x31, errorlevels[errorlevel]]);\n    } else {\n      throw new Error('Error level must be l, m, q or h');\n    }\n    /* Data */\n\n\n    const bytes = iconv.encode(value, 'iso88591');\n    const length = bytes.length; // + 3;\n\n    this._queue([0x1b, 0x1d, 0x79, 0x44, 0x31, 0x00, length % 0xff, length / 0xff, bytes // 0x1b, 0x1d, 0x79, 0x33, 0x31, 0x00, length % 0xff, length / 0xff, bytes\n    // 0x1d, 0x28, 0x6b, length % 0xff, length / 0xff, 0x31, 0x50, 0x30, bytes,\n    ]);\n    /* Print QR code */\n\n\n    this._queue([0x1b, 0x1d, 0x79, 0x50]);\n\n    return this;\n  }\n  /**\n     * Image\n     *\n     * @param  {object}         element  an element, like a canvas or image that needs to be printed\n     * @param  {number}         width  width of the image on the printer\n     * @param  {number}         height  height of the image on the printer\n     * @param  {string}         algorithm  the dithering algorithm for making the image black and white\n     * @param  {number}         threshold  threshold for the dithering algorithm\n     * @return {object}                  Return the object, for easy chaining commands\n     *\n     */\n\n\n  image(element, width, height, algorithm, threshold) {\n    if (width % 8 !== 0) {\n      throw new Error('Width must be a multiple of 8');\n    }\n\n    if (height % 24 !== 0) {\n      throw new Error('Height must be a multiple of 24');\n    }\n\n    if (typeof algorithm === 'undefined') {\n      algorithm = 'threshold';\n    }\n\n    if (typeof threshold === 'undefined') {\n      threshold = 128;\n    }\n\n    const canvas = createCanvas(width, height);\n    const context = canvas.getContext('2d');\n    context.drawImage(element, 0, 0, width, height);\n    let image = context.getImageData(0, 0, width, height);\n    image = Flatten.flatten(image, [0xff, 0xff, 0xff]);\n\n    switch (algorithm) {\n      case 'threshold':\n        image = Dither.threshold(image, threshold);\n        break;\n\n      case 'bayer':\n        image = Dither.bayer(image, threshold);\n        break;\n\n      case 'floydsteinberg':\n        image = Dither.floydsteinberg(image);\n        break;\n\n      case 'atkinson':\n        image = Dither.atkinson(image);\n        break;\n    }\n\n    const getPixel = (x, y) => image.data[(width * y + x) * 4] > 0 ? 0 : 1;\n\n    this._queue([0x1b, 0x30]);\n\n    for (let s = 0; s < height / 24; s++) {\n      const y = s * 24;\n      const bytes = new Uint8Array(width * 3);\n\n      for (let x = 0; x < width; x++) {\n        const i = x * 3;\n        bytes[i] = getPixel(x, y + 0) << 7 | getPixel(x, y + 1) << 6 | getPixel(x, y + 2) << 5 | getPixel(x, y + 3) << 4 | getPixel(x, y + 4) << 3 | getPixel(x, y + 5) << 2 | getPixel(x, y + 6) << 1 | getPixel(x, y + 7);\n        bytes[i + 1] = getPixel(x, y + 8) << 7 | getPixel(x, y + 9) << 6 | getPixel(x, y + 10) << 5 | getPixel(x, y + 11) << 4 | getPixel(x, y + 12) << 3 | getPixel(x, y + 13) << 2 | getPixel(x, y + 14) << 1 | getPixel(x, y + 15);\n        bytes[i + 2] = getPixel(x, y + 16) << 7 | getPixel(x, y + 17) << 6 | getPixel(x, y + 18) << 5 | getPixel(x, y + 19) << 4 | getPixel(x, y + 20) << 3 | getPixel(x, y + 21) << 2 | getPixel(x, y + 22) << 1 | getPixel(x, y + 23);\n      }\n\n      this._queue([0x1b, 0x58, width & 0xff, width >> 8 & 0xff, bytes, 0x0a, 0x0d]);\n    }\n\n    this._queue([0x1b, 0x7a, 0x01]);\n\n    return this;\n  }\n  /**\n     * Cut paper\n     *\n     * @param  {string}          value   full or partial. When not specified a full cut will be assumed\n     * @return {object}                  Return the object, for easy chaining commands\n     *\n     */\n\n\n  cut(value) {\n    let data = 0x00;\n\n    if (value == 'partial') {\n      data = 0x01;\n    }\n\n    this._queue([0x1b, 0x64, data]);\n\n    return this;\n  }\n  /**\n     * Add raw printer commands\n     *\n     * @param  {array}           data   raw bytes to be included\n     * @return {object}          Return the object, for easy chaining commands\n     *\n     */\n\n\n  raw(data) {\n    this._queue(data);\n\n    return this;\n  }\n  /**\n     * Encode all previous commands\n     *\n     * @return {Uint8Array}         Return the encoded bytes\n     *\n     */\n\n\n  encode() {\n    let length = 0;\n\n    this._buffer.forEach(item => {\n      if (typeof item === 'number') {\n        length++;\n      } else {\n        length += item.length;\n      }\n    });\n\n    const result = new Uint8Array(length);\n    let index = 0;\n\n    this._buffer.forEach(item => {\n      if (typeof item === 'number') {\n        result[index] = item;\n        index++;\n      } else {\n        result.set(item, index);\n        index += item.length;\n      }\n    });\n\n    this._reset();\n\n    return result;\n  }\n\n}\n\nmodule.exports = StarPrntEncoder;","map":{"version":3,"sources":["/Users/sirin/go/src/github.com/sirinibin/reactjs-pos/node_modules/star-prnt-encoder/src/star-prnt-encoder.js"],"names":["iconv","require","linewrap","createCanvas","Dither","Flatten","StarPrntEncoder","constructor","_reset","_buffer","_codepage","_state","_encode","value","encode","_queue","forEach","item","push","initialize","codepage","codepages","encodingExists","Error","encodings","text","wrap","w","lineBreak","bytes","newline","line","underline","Number","italic","bold","size","align","alignments","barcode","symbology","height","symbologies","qrcode","model","errorlevel","models","errorlevels","length","image","element","width","algorithm","threshold","canvas","context","getContext","drawImage","getImageData","flatten","bayer","floydsteinberg","atkinson","getPixel","x","y","data","s","Uint8Array","i","cut","raw","result","index","set","module","exports"],"mappings":"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","sourcesContent":["const iconv = require('iconv-lite');\nconst linewrap = require('linewrap');\nconst {createCanvas} = require('canvas');\nconst Dither = require('canvas-dither');\nconst Flatten = require('canvas-flatten');\n\n\n/**\n * Create a byte stream based on commands for ESC/POS printers\n */\nclass StarPrntEncoder {\n  /**\n     * Create a new object\n     *\n    */\n  constructor() {\n    this._reset();\n  }\n\n  /**\n     * Reset the state of the object\n     *\n    */\n  _reset() {\n    this._buffer = [];\n    this._codepage = 'ascii';\n\n    this._state = {\n      'bold': false,\n      'underline': false,\n    };\n  }\n\n  /**\n     * Encode a string with the current code page\n     *\n     * @param  {string}   value  String to encode\n     * @return {object}          Encoded string as a ArrayBuffer\n     *\n    */\n  _encode(value) {\n    return iconv.encode(value, this._codepage);\n  }\n\n  /**\n     * Add commands to the buffer\n     *\n     * @param  {array}   value  And array of numbers, arrays, buffers or Uint8Arrays to add to the buffer\n     *\n    */\n  _queue(value) {\n    value.forEach((item) => this._buffer.push(item));\n  }\n\n  /**\n     * Initialize the printer\n     *\n     * @return {object}          Return the object, for easy chaining commands\n     *\n     */\n  initialize() {\n    this._queue([\n      0x1b, 0x40, 0x18,\n    ]);\n\n    return this;\n  }\n\n  /**\n     * Change the code page\n     *\n     * @param  {string}   value  The codepage that we set the printer to\n     * @return {object}          Return the object, for easy chaining commands\n     *\n     */\n  codepage(value) {\n    const codepages = {\n      'cp437': 0x01,\n      'cp858': 0x04,\n      'cp852': 0x05,\n      'cp860': 0x06,\n      'cp861': 0x07,\n      'cp863': 0x08,\n      'cp865': 0x09,\n      'cp866': 0x0a,\n      'cp855': 0x0b,\n      'cp857': 0x0c,\n      'cp862': 0x0d,\n      'cp864': 0x0e,\n      'cp737': 0x0f,\n      'cp869': 0x11,\n      'windows874': 0x14,\n      'windows1252': 0x20,\n      'windows1250': 0x21,\n      'windows1251': 0x22,\n    };\n\n    let codepage;\n\n    if (!iconv.encodingExists(value)) {\n      throw new Error('Unknown codepage');\n    }\n\n    if (value in iconv.encodings) {\n      if (typeof iconv.encodings[value] === 'string') {\n        codepage = iconv.encodings[value];\n      } else {\n        codepage = value;\n      }\n    } else {\n      throw new Error('Unknown codepage');\n    }\n\n    if (typeof codepages[codepage] !== 'undefined') {\n      this._codepage = codepage;\n\n      this._queue([\n        0x1b, 0x1d, 0x74, codepages[codepage],\n      ]);\n    } else {\n      throw new Error('Codepage not supported by printer');\n    }\n\n    return this;\n  }\n\n  /**\n     * Print text\n     *\n     * @param  {string}   value  Text that needs to be printed\n     * @param  {number}   wrap   Wrap text after this many positions\n     * @return {object}          Return the object, for easy chaining commands\n     *\n     */\n  text(value, wrap) {\n    if (wrap) {\n      const w = linewrap(wrap, {lineBreak: '\\r\\n'});\n      value = w(value);\n    }\n\n    const bytes = this._encode(value);\n\n    this._queue([\n      bytes,\n    ]);\n\n    return this;\n  }\n\n  /**\n     * Print a newline\n     *\n     * @return {object}          Return the object, for easy chaining commands\n     *\n     */\n  newline() {\n    this._queue([\n      0x0a, 0x0d,\n    ]);\n\n    return this;\n  }\n\n  /**\n     * Print text, followed by a newline\n     *\n     * @param  {string}   value  Text that needs to be printed\n     * @param  {number}   wrap   Wrap text after this many positions\n     * @return {object}          Return the object, for easy chaining commands\n     *\n     */\n  line(value, wrap) {\n    this.text(value, wrap);\n    this.newline();\n\n    return this;\n  }\n\n  /**\n     * Underline text\n     *\n     * @param  {boolean|number}   value  true to turn on underline, false to turn off\n     * @return {object}                  Return the object, for easy chaining commands\n     *\n     */\n  underline(value) {\n    if (typeof value === 'undefined') {\n      value = ! this._state.underline;\n    }\n\n    this._state.underline = value;\n\n    this._queue([\n      0x1b, 0x2d, Number(value),\n    ]);\n\n    return this;\n  }\n\n  /**\n     * Italic text\n     * This is a no-op for StarPRNT, as this is not supported by printers.\n     * This function is for compatibility with EscPosEncoder, which does support italic.\n     *\n     * @param  {boolean}          value  true to turn on italic, false to turn off\n     * @return {object}                  Return the object, for easy chaining commands\n     *\n     */\n  italic(value) {\n    return this;\n  }\n\n  /**\n     * Bold text\n     *\n     * @param  {boolean}          value  true to turn on bold, false to turn off\n     * @return {object}                  Return the object, for easy chaining commands\n     *\n     */\n  bold(value) {\n    if (typeof value === 'undefined') {\n      value = ! this._state.bold;\n    }\n\n    this._state.bold = value;\n\n    if (value) {\n      this._queue([\n        0x1b, 0x45,\n      ]);\n    } else {\n      this._queue([\n        0x1b, 0x46,\n      ]);\n    }\n\n    return this;\n  }\n\n  /**\n     * Change text size\n     *\n     * @param  {string}          value   smaller, small or normal\n     * @return {object}                  Return the object, for easy chaining commands\n     *\n     */\n  size(value) {\n    if (value === 'smaller') {\n      value = 0x02;\n    } else if (value === 'small') {\n      value = 0x01;\n    } else {\n      value = 0x00;\n    }\n\n    this._queue([\n      0x1b, 0x1e, 0x46, value,\n    ]);\n\n    return this;\n  }\n\n  /**\n     * Change text alignment\n     *\n     * @param  {string}          value   left, center or right\n     * @return {object}                  Return the object, for easy chaining commands\n     *\n     */\n  align(value) {\n    const alignments = {\n      'left': 0x00,\n      'center': 0x01,\n      'right': 0x02,\n    };\n\n    if (value in alignments) {\n      this._queue([\n        0x1b, 0x1d, 0x61, alignments[value],\n      ]);\n    } else {\n      throw new Error('Unknown alignment');\n    }\n\n    return this;\n  }\n\n  /**\n     * Barcode\n     *\n     * @param  {string}           value  the value of the barcode\n     * @param  {string}           symbology  the type of the barcode\n     * @param  {number}           height  height of the barcode\n     * @return {object}                  Return the object, for easy chaining commands\n     *\n     */\n  barcode(value, symbology, height) {\n    const symbologies = {\n      'upce': 0x00,\n      'upca': 0x01,\n      'ean8': 0x02,\n      'ean13': 0x03,\n      'code39': 0x04,\n      'itf': 0x05,\n      'code128': 0x06,\n      'code93': 0x07,\n      'nw-7': 0x08,\n      'gs1-128': 0x09,\n      'gs1-databar-omni': 0x0a,\n      'gs1-databar-truncated': 0x0b,\n      'gs1-databar-limited': 0x0c,\n      'gs1-databar-expanded': 0x0d,\n    };\n\n    if (symbology in symbologies) {\n      const bytes = iconv.encode(value, 'ascii');\n\n      this._queue([\n        0x1b, 0x62,\n        symbologies[symbology], 0x01, 0x03, height,\n        bytes, 0x1e,\n      ]);\n    } else {\n      throw new Error('Symbology not supported by printer');\n    }\n\n    return this;\n  }\n\n  /**\n     * QR code\n     *\n     * @param  {string}           value  the value of the qr code\n     * @param  {number}           model  model of the qrcode, either 1 or 2\n     * @param  {number}           size   size of the qrcode, a value between 1 and 8\n     * @param  {string}           errorlevel  the amount of error correction used, either 'l', 'm', 'q', 'h'\n     * @return {object}                  Return the object, for easy chaining commands\n     *\n     */\n  qrcode(value, model, size, errorlevel) {\n    /* Force printing the print buffer and moving to a new line */\n\n    this._queue([\n      0x0a,\n    ]);\n\n    /* Model */\n\n    const models = {\n      1: 0x01,\n      2: 0x02,\n    };\n\n    if (typeof model === 'undefined') {\n      model = 2;\n    }\n\n    if (model in models) {\n      this._queue([\n        0x1b, 0x1d, 0x79, 0x53, 0x30, models[model],\n      ]);\n    } else {\n      throw new Error('Model must be 1 or 2');\n    }\n\n    /* Size */\n\n    if (typeof size === 'undefined') {\n      size = 6;\n    }\n\n    if (typeof size !== 'number') {\n      throw new Error('Size must be a number');\n    }\n\n    if (size < 1 || size > 8) {\n      throw new Error('Size must be between 1 and 8');\n    }\n\n    this._queue([\n      0x1b, 0x1d, 0x79, 0x53, 0x32, size,\n    ]);\n\n    /* Error level */\n\n    const errorlevels = {\n      'l': 0x00,\n      'm': 0x01,\n      'q': 0x02,\n      'h': 0x03,\n    };\n\n    if (typeof errorlevel === 'undefined') {\n      errorlevel = 'm';\n    }\n\n    if (errorlevel in errorlevels) {\n      this._queue([\n        0x1b, 0x1d, 0x79, 0x53, 0x31, errorlevels[errorlevel],\n      ]);\n    } else {\n      throw new Error('Error level must be l, m, q or h');\n    }\n\n    /* Data */\n\n    const bytes = iconv.encode(value, 'iso88591');\n    const length = bytes.length; // + 3;\n\n    this._queue([\n      0x1b, 0x1d, 0x79, 0x44, 0x31, 0x00, length % 0xff, length / 0xff, bytes,\n      // 0x1b, 0x1d, 0x79, 0x33, 0x31, 0x00, length % 0xff, length / 0xff, bytes\n      // 0x1d, 0x28, 0x6b, length % 0xff, length / 0xff, 0x31, 0x50, 0x30, bytes,\n    ]);\n\n    /* Print QR code */\n\n    this._queue([\n      0x1b, 0x1d, 0x79, 0x50,\n    ]);\n\n    return this;\n  }\n\n  /**\n     * Image\n     *\n     * @param  {object}         element  an element, like a canvas or image that needs to be printed\n     * @param  {number}         width  width of the image on the printer\n     * @param  {number}         height  height of the image on the printer\n     * @param  {string}         algorithm  the dithering algorithm for making the image black and white\n     * @param  {number}         threshold  threshold for the dithering algorithm\n     * @return {object}                  Return the object, for easy chaining commands\n     *\n     */\n  image(element, width, height, algorithm, threshold) {\n    if (width % 8 !== 0) {\n      throw new Error('Width must be a multiple of 8');\n    }\n\n    if (height % 24 !== 0) {\n      throw new Error('Height must be a multiple of 24');\n    }\n\n    if (typeof algorithm === 'undefined') {\n      algorithm = 'threshold';\n    }\n\n    if (typeof threshold === 'undefined') {\n      threshold = 128;\n    }\n\n    const canvas = createCanvas(width, height);\n    const context = canvas.getContext('2d');\n    context.drawImage(element, 0, 0, width, height);\n    let image = context.getImageData(0, 0, width, height);\n\n    image = Flatten.flatten(image, [0xff, 0xff, 0xff]);\n\n    switch (algorithm) {\n      case 'threshold': image = Dither.threshold(image, threshold); break;\n      case 'bayer': image = Dither.bayer(image, threshold); break;\n      case 'floydsteinberg': image = Dither.floydsteinberg(image); break;\n      case 'atkinson': image = Dither.atkinson(image); break;\n    }\n\n    const getPixel = (x, y) => image.data[((width * y) + x) * 4] > 0 ? 0 : 1;\n\n\n    this._queue([\n      0x1b, 0x30,\n    ]);\n\n    for (let s = 0; s < height / 24; s++) {\n      const y = s * 24;\n      const bytes = new Uint8Array(width * 3);\n\n      for (let x = 0; x < width; x++) {\n        const i = x * 3;\n\n        bytes[i] =\n            getPixel(x, y + 0) << 7 |\n            getPixel(x, y + 1) << 6 |\n            getPixel(x, y + 2) << 5 |\n            getPixel(x, y + 3) << 4 |\n            getPixel(x, y + 4) << 3 |\n            getPixel(x, y + 5) << 2 |\n            getPixel(x, y + 6) << 1 |\n            getPixel(x, y + 7);\n\n        bytes[i + 1] =\n            getPixel(x, y + 8) << 7 |\n            getPixel(x, y + 9) << 6 |\n            getPixel(x, y + 10) << 5 |\n            getPixel(x, y + 11) << 4 |\n            getPixel(x, y + 12) << 3 |\n            getPixel(x, y + 13) << 2 |\n            getPixel(x, y + 14) << 1 |\n            getPixel(x, y + 15);\n\n        bytes[i + 2] =\n            getPixel(x, y + 16) << 7 |\n            getPixel(x, y + 17) << 6 |\n            getPixel(x, y + 18) << 5 |\n            getPixel(x, y + 19) << 4 |\n            getPixel(x, y + 20) << 3 |\n            getPixel(x, y + 21) << 2 |\n            getPixel(x, y + 22) << 1 |\n            getPixel(x, y + 23);\n      }\n\n      this._queue([\n        0x1b, 0x58,\n        width & 0xff, ((width >> 8) & 0xff),\n        bytes,\n        0x0a, 0x0d,\n      ]);\n    }\n\n    this._queue([\n      0x1b, 0x7a, 0x01,\n    ]);\n\n    return this;\n  }\n\n  /**\n     * Cut paper\n     *\n     * @param  {string}          value   full or partial. When not specified a full cut will be assumed\n     * @return {object}                  Return the object, for easy chaining commands\n     *\n     */\n  cut(value) {\n    let data = 0x00;\n\n    if (value == 'partial') {\n      data = 0x01;\n    }\n\n    this._queue([\n      0x1b, 0x64, data,\n    ]);\n\n    return this;\n  }\n\n  /**\n     * Add raw printer commands\n     *\n     * @param  {array}           data   raw bytes to be included\n     * @return {object}          Return the object, for easy chaining commands\n     *\n     */\n  raw(data) {\n    this._queue(data);\n\n    return this;\n  }\n\n  /**\n     * Encode all previous commands\n     *\n     * @return {Uint8Array}         Return the encoded bytes\n     *\n     */\n  encode() {\n    let length = 0;\n\n    this._buffer.forEach((item) => {\n      if (typeof item === 'number') {\n        length++;\n      } else {\n        length += item.length;\n      }\n    });\n\n    const result = new Uint8Array(length);\n\n    let index = 0;\n\n    this._buffer.forEach((item) => {\n      if (typeof item === 'number') {\n        result[index] = item;\n        index++;\n      } else {\n        result.set(item, index);\n        index += item.length;\n      }\n    });\n\n    this._reset();\n\n    return result;\n  }\n}\n\nmodule.exports = StarPrntEncoder;\n"]},"metadata":{},"sourceType":"script"}